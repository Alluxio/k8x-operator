{"ast":null,"code":"import { tokenType } from './cst.js';\nimport { Lexer } from './lexer.js';\nfunction includesToken(list, type) {\n  for (let i = 0; i < list.length; ++i) if (list[i].type === type) return true;\n  return false;\n}\nfunction findNonEmptyIndex(list) {\n  for (let i = 0; i < list.length; ++i) {\n    switch (list[i].type) {\n      case 'space':\n      case 'comment':\n      case 'newline':\n        break;\n      default:\n        return i;\n    }\n  }\n  return -1;\n}\nfunction isFlowToken(token) {\n  switch (token === null || token === void 0 ? void 0 : token.type) {\n    case 'alias':\n    case 'scalar':\n    case 'single-quoted-scalar':\n    case 'double-quoted-scalar':\n    case 'flow-collection':\n      return true;\n    default:\n      return false;\n  }\n}\nfunction getPrevProps(parent) {\n  switch (parent.type) {\n    case 'document':\n      return parent.start;\n    case 'block-map':\n      {\n        var _it$sep;\n        const it = parent.items[parent.items.length - 1];\n        return (_it$sep = it.sep) !== null && _it$sep !== void 0 ? _it$sep : it.start;\n      }\n    case 'block-seq':\n      return parent.items[parent.items.length - 1].start;\n    /* istanbul ignore next should not happen */\n    default:\n      return [];\n  }\n}\n/** Note: May modify input array */\nfunction getFirstKeyStartProps(prev) {\n  if (prev.length === 0) return [];\n  let i = prev.length;\n  loop: while (--i >= 0) {\n    switch (prev[i].type) {\n      case 'doc-start':\n      case 'explicit-key-ind':\n      case 'map-value-ind':\n      case 'seq-item-ind':\n      case 'newline':\n        break loop;\n    }\n  }\n  while (((_prev$i = prev[++i]) === null || _prev$i === void 0 ? void 0 : _prev$i.type) === 'space') {\n    var _prev$i;\n  } /* loop */\n  return prev.splice(i, prev.length);\n}\nfunction fixFlowSeqItems(fc) {\n  if (fc.start.type === 'flow-seq-start') {\n    for (const it of fc.items) {\n      if (it.sep && !it.value && !includesToken(it.start, 'explicit-key-ind') && !includesToken(it.sep, 'map-value-ind')) {\n        if (it.key) it.value = it.key;\n        delete it.key;\n        if (isFlowToken(it.value)) {\n          if (it.value.end) Array.prototype.push.apply(it.value.end, it.sep);else it.value.end = it.sep;\n        } else Array.prototype.push.apply(it.start, it.sep);\n        delete it.sep;\n      }\n    }\n  }\n}\n/**\n * A YAML concrete syntax tree (CST) parser\n *\n * ```ts\n * const src: string = ...\n * for (const token of new Parser().parse(src)) {\n *   // token: Token\n * }\n * ```\n *\n * To use the parser with a user-provided lexer:\n *\n * ```ts\n * function* parse(source: string, lexer: Lexer) {\n *   const parser = new Parser()\n *   for (const lexeme of lexer.lex(source))\n *     yield* parser.next(lexeme)\n *   yield* parser.end()\n * }\n *\n * const src: string = ...\n * const lexer = new Lexer()\n * for (const token of parse(src, lexer)) {\n *   // token: Token\n * }\n * ```\n */\nclass Parser {\n  /**\n   * @param onNewLine - If defined, called separately with the start position of\n   *   each new line (in `parse()`, including the start of input).\n   */\n  constructor(onNewLine) {\n    /** If true, space and sequence indicators count as indentation */\n    this.atNewLine = true;\n    /** If true, next token is a scalar value */\n    this.atScalar = false;\n    /** Current indentation level */\n    this.indent = 0;\n    /** Current offset since the start of parsing */\n    this.offset = 0;\n    /** On the same line with a block map key */\n    this.onKeyLine = false;\n    /** Top indicates the node that's currently being built */\n    this.stack = [];\n    /** The source of the current token, set in parse() */\n    this.source = '';\n    /** The type of the current token, set in parse() */\n    this.type = '';\n    // Must be defined after `next()`\n    this.lexer = new Lexer();\n    this.onNewLine = onNewLine;\n  }\n  /**\n   * Parse `source` as a YAML stream.\n   * If `incomplete`, a part of the last line may be left as a buffer for the next call.\n   *\n   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.\n   *\n   * @returns A generator of tokens representing each directive, document, and other structure.\n   */\n  parse(source) {\n    var _this = this;\n    let incomplete = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return function* () {\n      if (_this.onNewLine && _this.offset === 0) _this.onNewLine(0);\n      for (const lexeme of _this.lexer.lex(source, incomplete)) yield* _this.next(lexeme);\n      if (!incomplete) yield* _this.end();\n    }();\n  }\n  /**\n   * Advance the parser by the `source` of one lexical token.\n   */\n  *next(source) {\n    this.source = source;\n    if (this.atScalar) {\n      this.atScalar = false;\n      yield* this.step();\n      this.offset += source.length;\n      return;\n    }\n    const type = tokenType(source);\n    if (!type) {\n      const message = \"Not a YAML token: \".concat(source);\n      yield* this.pop({\n        type: 'error',\n        offset: this.offset,\n        message,\n        source\n      });\n      this.offset += source.length;\n    } else if (type === 'scalar') {\n      this.atNewLine = false;\n      this.atScalar = true;\n      this.type = 'scalar';\n    } else {\n      this.type = type;\n      yield* this.step();\n      switch (type) {\n        case 'newline':\n          this.atNewLine = true;\n          this.indent = 0;\n          if (this.onNewLine) this.onNewLine(this.offset + source.length);\n          break;\n        case 'space':\n          if (this.atNewLine && source[0] === ' ') this.indent += source.length;\n          break;\n        case 'explicit-key-ind':\n        case 'map-value-ind':\n        case 'seq-item-ind':\n          if (this.atNewLine) this.indent += source.length;\n          break;\n        case 'doc-mode':\n        case 'flow-error-end':\n          return;\n        default:\n          this.atNewLine = false;\n      }\n      this.offset += source.length;\n    }\n  }\n  /** Call at end of input to push out any remaining constructions */\n  *end() {\n    while (this.stack.length > 0) yield* this.pop();\n  }\n  get sourceToken() {\n    const st = {\n      type: this.type,\n      offset: this.offset,\n      indent: this.indent,\n      source: this.source\n    };\n    return st;\n  }\n  *step() {\n    const top = this.peek(1);\n    if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {\n      while (this.stack.length > 0) yield* this.pop();\n      this.stack.push({\n        type: 'doc-end',\n        offset: this.offset,\n        source: this.source\n      });\n      return;\n    }\n    if (!top) return yield* this.stream();\n    switch (top.type) {\n      case 'document':\n        return yield* this.document(top);\n      case 'alias':\n      case 'scalar':\n      case 'single-quoted-scalar':\n      case 'double-quoted-scalar':\n        return yield* this.scalar(top);\n      case 'block-scalar':\n        return yield* this.blockScalar(top);\n      case 'block-map':\n        return yield* this.blockMap(top);\n      case 'block-seq':\n        return yield* this.blockSequence(top);\n      case 'flow-collection':\n        return yield* this.flowCollection(top);\n      case 'doc-end':\n        return yield* this.documentEnd(top);\n    }\n    /* istanbul ignore next should not happen */\n    yield* this.pop();\n  }\n  peek(n) {\n    return this.stack[this.stack.length - n];\n  }\n  *pop(error) {\n    const token = error !== null && error !== void 0 ? error : this.stack.pop();\n    /* istanbul ignore if should not happen */\n    if (!token) {\n      const message = 'Tried to pop an empty stack';\n      yield {\n        type: 'error',\n        offset: this.offset,\n        source: '',\n        message\n      };\n    } else if (this.stack.length === 0) {\n      yield token;\n    } else {\n      const top = this.peek(1);\n      if (token.type === 'block-scalar') {\n        // Block scalars use their parent rather than header indent\n        token.indent = 'indent' in top ? top.indent : 0;\n      } else if (token.type === 'flow-collection' && top.type === 'document') {\n        // Ignore all indent for top-level flow collections\n        token.indent = 0;\n      }\n      if (token.type === 'flow-collection') fixFlowSeqItems(token);\n      switch (top.type) {\n        case 'document':\n          top.value = token;\n          break;\n        case 'block-scalar':\n          top.props.push(token); // error\n          break;\n        case 'block-map':\n          {\n            const it = top.items[top.items.length - 1];\n            if (it.value) {\n              top.items.push({\n                start: [],\n                key: token,\n                sep: []\n              });\n              this.onKeyLine = true;\n              return;\n            } else if (it.sep) {\n              it.value = token;\n            } else {\n              Object.assign(it, {\n                key: token,\n                sep: []\n              });\n              this.onKeyLine = !includesToken(it.start, 'explicit-key-ind');\n              return;\n            }\n            break;\n          }\n        case 'block-seq':\n          {\n            const it = top.items[top.items.length - 1];\n            if (it.value) top.items.push({\n              start: [],\n              value: token\n            });else it.value = token;\n            break;\n          }\n        case 'flow-collection':\n          {\n            const it = top.items[top.items.length - 1];\n            if (!it || it.value) top.items.push({\n              start: [],\n              key: token,\n              sep: []\n            });else if (it.sep) it.value = token;else Object.assign(it, {\n              key: token,\n              sep: []\n            });\n            return;\n          }\n        /* istanbul ignore next should not happen */\n        default:\n          yield* this.pop();\n          yield* this.pop(token);\n      }\n      if ((top.type === 'document' || top.type === 'block-map' || top.type === 'block-seq') && (token.type === 'block-map' || token.type === 'block-seq')) {\n        const last = token.items[token.items.length - 1];\n        if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {\n          if (top.type === 'document') top.end = last.start;else top.items.push({\n            start: last.start\n          });\n          token.items.splice(-1, 1);\n        }\n      }\n    }\n  }\n  *stream() {\n    switch (this.type) {\n      case 'directive-line':\n        yield {\n          type: 'directive',\n          offset: this.offset,\n          source: this.source\n        };\n        return;\n      case 'byte-order-mark':\n      case 'space':\n      case 'comment':\n      case 'newline':\n        yield this.sourceToken;\n        return;\n      case 'doc-mode':\n      case 'doc-start':\n        {\n          const doc = {\n            type: 'document',\n            offset: this.offset,\n            start: []\n          };\n          if (this.type === 'doc-start') doc.start.push(this.sourceToken);\n          this.stack.push(doc);\n          return;\n        }\n    }\n    yield {\n      type: 'error',\n      offset: this.offset,\n      message: \"Unexpected \".concat(this.type, \" token in YAML stream\"),\n      source: this.source\n    };\n  }\n  *document(doc) {\n    if (doc.value) return yield* this.lineEnd(doc);\n    switch (this.type) {\n      case 'doc-start':\n        {\n          if (findNonEmptyIndex(doc.start) !== -1) {\n            yield* this.pop();\n            yield* this.step();\n          } else doc.start.push(this.sourceToken);\n          return;\n        }\n      case 'anchor':\n      case 'tag':\n      case 'space':\n      case 'comment':\n      case 'newline':\n        doc.start.push(this.sourceToken);\n        return;\n    }\n    const bv = this.startBlockValue(doc);\n    if (bv) this.stack.push(bv);else {\n      yield {\n        type: 'error',\n        offset: this.offset,\n        message: \"Unexpected \".concat(this.type, \" token in YAML document\"),\n        source: this.source\n      };\n    }\n  }\n  *scalar(scalar) {\n    if (this.type === 'map-value-ind') {\n      const prev = getPrevProps(this.peek(2));\n      const start = getFirstKeyStartProps(prev);\n      let sep;\n      if (scalar.end) {\n        sep = scalar.end;\n        sep.push(this.sourceToken);\n        delete scalar.end;\n      } else sep = [this.sourceToken];\n      const map = {\n        type: 'block-map',\n        offset: scalar.offset,\n        indent: scalar.indent,\n        items: [{\n          start,\n          key: scalar,\n          sep\n        }]\n      };\n      this.onKeyLine = true;\n      this.stack[this.stack.length - 1] = map;\n    } else yield* this.lineEnd(scalar);\n  }\n  *blockScalar(scalar) {\n    switch (this.type) {\n      case 'space':\n      case 'comment':\n      case 'newline':\n        scalar.props.push(this.sourceToken);\n        return;\n      case 'scalar':\n        scalar.source = this.source;\n        // block-scalar source includes trailing newline\n        this.atNewLine = true;\n        this.indent = 0;\n        if (this.onNewLine) {\n          let nl = this.source.indexOf('\\n') + 1;\n          while (nl !== 0) {\n            this.onNewLine(this.offset + nl);\n            nl = this.source.indexOf('\\n', nl) + 1;\n          }\n        }\n        yield* this.pop();\n        break;\n      /* istanbul ignore next should not happen */\n      default:\n        yield* this.pop();\n        yield* this.step();\n    }\n  }\n  *blockMap(map) {\n    const it = map.items[map.items.length - 1];\n    // it.sep is true-ish if pair already has key or : separator\n    switch (this.type) {\n      case 'newline':\n        this.onKeyLine = false;\n        if (it.value) {\n          const end = 'end' in it.value ? it.value.end : undefined;\n          const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n          if ((last === null || last === void 0 ? void 0 : last.type) === 'comment') end === null || end === void 0 || end.push(this.sourceToken);else map.items.push({\n            start: [this.sourceToken]\n          });\n        } else if (it.sep) {\n          it.sep.push(this.sourceToken);\n        } else {\n          it.start.push(this.sourceToken);\n        }\n        return;\n      case 'space':\n      case 'comment':\n        if (it.value) {\n          map.items.push({\n            start: [this.sourceToken]\n          });\n        } else if (it.sep) {\n          it.sep.push(this.sourceToken);\n        } else {\n          if (this.atIndentedComment(it.start, map.indent)) {\n            var _prev$value;\n            const prev = map.items[map.items.length - 2];\n            const end = prev === null || prev === void 0 || (_prev$value = prev.value) === null || _prev$value === void 0 ? void 0 : _prev$value.end;\n            if (Array.isArray(end)) {\n              Array.prototype.push.apply(end, it.start);\n              end.push(this.sourceToken);\n              map.items.pop();\n              return;\n            }\n          }\n          it.start.push(this.sourceToken);\n        }\n        return;\n    }\n    if (this.indent >= map.indent) {\n      const atNextItem = !this.onKeyLine && this.indent === map.indent && it.sep;\n      // For empty nodes, assign newline-separated not indented empty tokens to following node\n      let start = [];\n      if (atNextItem && it.sep && !it.value) {\n        const nl = [];\n        for (let i = 0; i < it.sep.length; ++i) {\n          const st = it.sep[i];\n          switch (st.type) {\n            case 'newline':\n              nl.push(i);\n              break;\n            case 'space':\n              break;\n            case 'comment':\n              if (st.indent > map.indent) nl.length = 0;\n              break;\n            default:\n              nl.length = 0;\n          }\n        }\n        if (nl.length >= 2) start = it.sep.splice(nl[1]);\n      }\n      switch (this.type) {\n        case 'anchor':\n        case 'tag':\n          if (atNextItem || it.value) {\n            start.push(this.sourceToken);\n            map.items.push({\n              start\n            });\n            this.onKeyLine = true;\n          } else if (it.sep) {\n            it.sep.push(this.sourceToken);\n          } else {\n            it.start.push(this.sourceToken);\n          }\n          return;\n        case 'explicit-key-ind':\n          if (!it.sep && !includesToken(it.start, 'explicit-key-ind')) {\n            it.start.push(this.sourceToken);\n          } else if (atNextItem || it.value) {\n            start.push(this.sourceToken);\n            map.items.push({\n              start\n            });\n          } else {\n            this.stack.push({\n              type: 'block-map',\n              offset: this.offset,\n              indent: this.indent,\n              items: [{\n                start: [this.sourceToken]\n              }]\n            });\n          }\n          this.onKeyLine = true;\n          return;\n        case 'map-value-ind':\n          if (includesToken(it.start, 'explicit-key-ind')) {\n            if (!it.sep) {\n              if (includesToken(it.start, 'newline')) {\n                Object.assign(it, {\n                  key: null,\n                  sep: [this.sourceToken]\n                });\n              } else {\n                const start = getFirstKeyStartProps(it.start);\n                this.stack.push({\n                  type: 'block-map',\n                  offset: this.offset,\n                  indent: this.indent,\n                  items: [{\n                    start,\n                    key: null,\n                    sep: [this.sourceToken]\n                  }]\n                });\n              }\n            } else if (it.value) {\n              map.items.push({\n                start: [],\n                key: null,\n                sep: [this.sourceToken]\n              });\n            } else if (includesToken(it.sep, 'map-value-ind')) {\n              this.stack.push({\n                type: 'block-map',\n                offset: this.offset,\n                indent: this.indent,\n                items: [{\n                  start,\n                  key: null,\n                  sep: [this.sourceToken]\n                }]\n              });\n            } else if (isFlowToken(it.key) && !includesToken(it.sep, 'newline')) {\n              const start = getFirstKeyStartProps(it.start);\n              const key = it.key;\n              const sep = it.sep;\n              sep.push(this.sourceToken);\n              // @ts-expect-error type guard is wrong here\n              delete it.key, delete it.sep;\n              this.stack.push({\n                type: 'block-map',\n                offset: this.offset,\n                indent: this.indent,\n                items: [{\n                  start,\n                  key,\n                  sep\n                }]\n              });\n            } else if (start.length > 0) {\n              // Not actually at next item\n              it.sep = it.sep.concat(start, this.sourceToken);\n            } else {\n              it.sep.push(this.sourceToken);\n            }\n          } else {\n            if (!it.sep) {\n              Object.assign(it, {\n                key: null,\n                sep: [this.sourceToken]\n              });\n            } else if (it.value || atNextItem) {\n              map.items.push({\n                start,\n                key: null,\n                sep: [this.sourceToken]\n              });\n            } else if (includesToken(it.sep, 'map-value-ind')) {\n              this.stack.push({\n                type: 'block-map',\n                offset: this.offset,\n                indent: this.indent,\n                items: [{\n                  start: [],\n                  key: null,\n                  sep: [this.sourceToken]\n                }]\n              });\n            } else {\n              it.sep.push(this.sourceToken);\n            }\n          }\n          this.onKeyLine = true;\n          return;\n        case 'alias':\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n          {\n            const fs = this.flowScalar(this.type);\n            if (atNextItem || it.value) {\n              map.items.push({\n                start,\n                key: fs,\n                sep: []\n              });\n              this.onKeyLine = true;\n            } else if (it.sep) {\n              this.stack.push(fs);\n            } else {\n              Object.assign(it, {\n                key: fs,\n                sep: []\n              });\n              this.onKeyLine = true;\n            }\n            return;\n          }\n        default:\n          {\n            const bv = this.startBlockValue(map);\n            if (bv) {\n              if (atNextItem && bv.type !== 'block-seq' && includesToken(it.start, 'explicit-key-ind')) {\n                map.items.push({\n                  start\n                });\n              }\n              this.stack.push(bv);\n              return;\n            }\n          }\n      }\n    }\n    yield* this.pop();\n    yield* this.step();\n  }\n  *blockSequence(seq) {\n    const it = seq.items[seq.items.length - 1];\n    switch (this.type) {\n      case 'newline':\n        if (it.value) {\n          const end = 'end' in it.value ? it.value.end : undefined;\n          const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n          if ((last === null || last === void 0 ? void 0 : last.type) === 'comment') end === null || end === void 0 || end.push(this.sourceToken);else seq.items.push({\n            start: [this.sourceToken]\n          });\n        } else it.start.push(this.sourceToken);\n        return;\n      case 'space':\n      case 'comment':\n        if (it.value) seq.items.push({\n          start: [this.sourceToken]\n        });else {\n          if (this.atIndentedComment(it.start, seq.indent)) {\n            var _prev$value2;\n            const prev = seq.items[seq.items.length - 2];\n            const end = prev === null || prev === void 0 || (_prev$value2 = prev.value) === null || _prev$value2 === void 0 ? void 0 : _prev$value2.end;\n            if (Array.isArray(end)) {\n              Array.prototype.push.apply(end, it.start);\n              end.push(this.sourceToken);\n              seq.items.pop();\n              return;\n            }\n          }\n          it.start.push(this.sourceToken);\n        }\n        return;\n      case 'anchor':\n      case 'tag':\n        if (it.value || this.indent <= seq.indent) break;\n        it.start.push(this.sourceToken);\n        return;\n      case 'seq-item-ind':\n        if (this.indent !== seq.indent) break;\n        if (it.value || includesToken(it.start, 'seq-item-ind')) seq.items.push({\n          start: [this.sourceToken]\n        });else it.start.push(this.sourceToken);\n        return;\n    }\n    if (this.indent > seq.indent) {\n      const bv = this.startBlockValue(seq);\n      if (bv) {\n        this.stack.push(bv);\n        return;\n      }\n    }\n    yield* this.pop();\n    yield* this.step();\n  }\n  *flowCollection(fc) {\n    const it = fc.items[fc.items.length - 1];\n    if (this.type === 'flow-error-end') {\n      let top;\n      do {\n        yield* this.pop();\n        top = this.peek(1);\n      } while (top && top.type === 'flow-collection');\n    } else if (fc.end.length === 0) {\n      switch (this.type) {\n        case 'comma':\n        case 'explicit-key-ind':\n          if (!it || it.sep) fc.items.push({\n            start: [this.sourceToken]\n          });else it.start.push(this.sourceToken);\n          return;\n        case 'map-value-ind':\n          if (!it || it.value) fc.items.push({\n            start: [],\n            key: null,\n            sep: [this.sourceToken]\n          });else if (it.sep) it.sep.push(this.sourceToken);else Object.assign(it, {\n            key: null,\n            sep: [this.sourceToken]\n          });\n          return;\n        case 'space':\n        case 'comment':\n        case 'newline':\n        case 'anchor':\n        case 'tag':\n          if (!it || it.value) fc.items.push({\n            start: [this.sourceToken]\n          });else if (it.sep) it.sep.push(this.sourceToken);else it.start.push(this.sourceToken);\n          return;\n        case 'alias':\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n          {\n            const fs = this.flowScalar(this.type);\n            if (!it || it.value) fc.items.push({\n              start: [],\n              key: fs,\n              sep: []\n            });else if (it.sep) this.stack.push(fs);else Object.assign(it, {\n              key: fs,\n              sep: []\n            });\n            return;\n          }\n        case 'flow-map-end':\n        case 'flow-seq-end':\n          fc.end.push(this.sourceToken);\n          return;\n      }\n      const bv = this.startBlockValue(fc);\n      /* istanbul ignore else should not happen */\n      if (bv) this.stack.push(bv);else {\n        yield* this.pop();\n        yield* this.step();\n      }\n    } else {\n      const parent = this.peek(2);\n      if (parent.type === 'block-map' && (this.type === 'map-value-ind' && parent.indent === fc.indent || this.type === 'newline' && !parent.items[parent.items.length - 1].sep)) {\n        yield* this.pop();\n        yield* this.step();\n      } else if (this.type === 'map-value-ind' && parent.type !== 'flow-collection') {\n        const prev = getPrevProps(parent);\n        const start = getFirstKeyStartProps(prev);\n        fixFlowSeqItems(fc);\n        const sep = fc.end.splice(1, fc.end.length);\n        sep.push(this.sourceToken);\n        const map = {\n          type: 'block-map',\n          offset: fc.offset,\n          indent: fc.indent,\n          items: [{\n            start,\n            key: fc,\n            sep\n          }]\n        };\n        this.onKeyLine = true;\n        this.stack[this.stack.length - 1] = map;\n      } else {\n        yield* this.lineEnd(fc);\n      }\n    }\n  }\n  flowScalar(type) {\n    if (this.onNewLine) {\n      let nl = this.source.indexOf('\\n') + 1;\n      while (nl !== 0) {\n        this.onNewLine(this.offset + nl);\n        nl = this.source.indexOf('\\n', nl) + 1;\n      }\n    }\n    return {\n      type,\n      offset: this.offset,\n      indent: this.indent,\n      source: this.source\n    };\n  }\n  startBlockValue(parent) {\n    switch (this.type) {\n      case 'alias':\n      case 'scalar':\n      case 'single-quoted-scalar':\n      case 'double-quoted-scalar':\n        return this.flowScalar(this.type);\n      case 'block-scalar-header':\n        return {\n          type: 'block-scalar',\n          offset: this.offset,\n          indent: this.indent,\n          props: [this.sourceToken],\n          source: ''\n        };\n      case 'flow-map-start':\n      case 'flow-seq-start':\n        return {\n          type: 'flow-collection',\n          offset: this.offset,\n          indent: this.indent,\n          start: this.sourceToken,\n          items: [],\n          end: []\n        };\n      case 'seq-item-ind':\n        return {\n          type: 'block-seq',\n          offset: this.offset,\n          indent: this.indent,\n          items: [{\n            start: [this.sourceToken]\n          }]\n        };\n      case 'explicit-key-ind':\n        {\n          this.onKeyLine = true;\n          const prev = getPrevProps(parent);\n          const start = getFirstKeyStartProps(prev);\n          start.push(this.sourceToken);\n          return {\n            type: 'block-map',\n            offset: this.offset,\n            indent: this.indent,\n            items: [{\n              start\n            }]\n          };\n        }\n      case 'map-value-ind':\n        {\n          this.onKeyLine = true;\n          const prev = getPrevProps(parent);\n          const start = getFirstKeyStartProps(prev);\n          return {\n            type: 'block-map',\n            offset: this.offset,\n            indent: this.indent,\n            items: [{\n              start,\n              key: null,\n              sep: [this.sourceToken]\n            }]\n          };\n        }\n    }\n    return null;\n  }\n  atIndentedComment(start, indent) {\n    if (this.type !== 'comment') return false;\n    if (this.indent <= indent) return false;\n    return start.every(st => st.type === 'newline' || st.type === 'space');\n  }\n  *documentEnd(docEnd) {\n    if (this.type !== 'doc-mode') {\n      if (docEnd.end) docEnd.end.push(this.sourceToken);else docEnd.end = [this.sourceToken];\n      if (this.type === 'newline') yield* this.pop();\n    }\n  }\n  *lineEnd(token) {\n    switch (this.type) {\n      case 'comma':\n      case 'doc-start':\n      case 'doc-end':\n      case 'flow-seq-end':\n      case 'flow-map-end':\n      case 'map-value-ind':\n        yield* this.pop();\n        yield* this.step();\n        break;\n      case 'newline':\n        this.onKeyLine = false;\n      // fallthrough\n      case 'space':\n      case 'comment':\n      default:\n        // all other values are errors\n        if (token.end) token.end.push(this.sourceToken);else token.end = [this.sourceToken];\n        if (this.type === 'newline') yield* this.pop();\n    }\n  }\n}\nexport { Parser };","map":{"version":3,"names":["tokenType","Lexer","includesToken","list","type","i","length","findNonEmptyIndex","isFlowToken","token","getPrevProps","parent","start","_it$sep","it","items","sep","getFirstKeyStartProps","prev","loop","_prev$i","splice","fixFlowSeqItems","fc","value","key","end","Array","prototype","push","apply","Parser","constructor","onNewLine","atNewLine","atScalar","indent","offset","onKeyLine","stack","source","lexer","parse","_this","incomplete","arguments","undefined","lexeme","lex","next","step","message","concat","pop","sourceToken","st","top","peek","stream","document","scalar","blockScalar","blockMap","blockSequence","flowCollection","documentEnd","n","error","props","Object","assign","last","every","doc","lineEnd","bv","startBlockValue","map","nl","indexOf","isArray","atIndentedComment","_prev$value","atNextItem","fs","flowScalar","seq","_prev$value2","docEnd"],"sources":["/Users/shoukaiwen/WebstormProjects/alluxio-k8s-operator-ui/node_modules/yaml/browser/dist/parse/parser.js"],"sourcesContent":["import { tokenType } from './cst.js';\nimport { Lexer } from './lexer.js';\n\nfunction includesToken(list, type) {\n    for (let i = 0; i < list.length; ++i)\n        if (list[i].type === type)\n            return true;\n    return false;\n}\nfunction findNonEmptyIndex(list) {\n    for (let i = 0; i < list.length; ++i) {\n        switch (list[i].type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                break;\n            default:\n                return i;\n        }\n    }\n    return -1;\n}\nfunction isFlowToken(token) {\n    switch (token?.type) {\n        case 'alias':\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'flow-collection':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction getPrevProps(parent) {\n    switch (parent.type) {\n        case 'document':\n            return parent.start;\n        case 'block-map': {\n            const it = parent.items[parent.items.length - 1];\n            return it.sep ?? it.start;\n        }\n        case 'block-seq':\n            return parent.items[parent.items.length - 1].start;\n        /* istanbul ignore next should not happen */\n        default:\n            return [];\n    }\n}\n/** Note: May modify input array */\nfunction getFirstKeyStartProps(prev) {\n    if (prev.length === 0)\n        return [];\n    let i = prev.length;\n    loop: while (--i >= 0) {\n        switch (prev[i].type) {\n            case 'doc-start':\n            case 'explicit-key-ind':\n            case 'map-value-ind':\n            case 'seq-item-ind':\n            case 'newline':\n                break loop;\n        }\n    }\n    while (prev[++i]?.type === 'space') {\n        /* loop */\n    }\n    return prev.splice(i, prev.length);\n}\nfunction fixFlowSeqItems(fc) {\n    if (fc.start.type === 'flow-seq-start') {\n        for (const it of fc.items) {\n            if (it.sep &&\n                !it.value &&\n                !includesToken(it.start, 'explicit-key-ind') &&\n                !includesToken(it.sep, 'map-value-ind')) {\n                if (it.key)\n                    it.value = it.key;\n                delete it.key;\n                if (isFlowToken(it.value)) {\n                    if (it.value.end)\n                        Array.prototype.push.apply(it.value.end, it.sep);\n                    else\n                        it.value.end = it.sep;\n                }\n                else\n                    Array.prototype.push.apply(it.start, it.sep);\n                delete it.sep;\n            }\n        }\n    }\n}\n/**\n * A YAML concrete syntax tree (CST) parser\n *\n * ```ts\n * const src: string = ...\n * for (const token of new Parser().parse(src)) {\n *   // token: Token\n * }\n * ```\n *\n * To use the parser with a user-provided lexer:\n *\n * ```ts\n * function* parse(source: string, lexer: Lexer) {\n *   const parser = new Parser()\n *   for (const lexeme of lexer.lex(source))\n *     yield* parser.next(lexeme)\n *   yield* parser.end()\n * }\n *\n * const src: string = ...\n * const lexer = new Lexer()\n * for (const token of parse(src, lexer)) {\n *   // token: Token\n * }\n * ```\n */\nclass Parser {\n    /**\n     * @param onNewLine - If defined, called separately with the start position of\n     *   each new line (in `parse()`, including the start of input).\n     */\n    constructor(onNewLine) {\n        /** If true, space and sequence indicators count as indentation */\n        this.atNewLine = true;\n        /** If true, next token is a scalar value */\n        this.atScalar = false;\n        /** Current indentation level */\n        this.indent = 0;\n        /** Current offset since the start of parsing */\n        this.offset = 0;\n        /** On the same line with a block map key */\n        this.onKeyLine = false;\n        /** Top indicates the node that's currently being built */\n        this.stack = [];\n        /** The source of the current token, set in parse() */\n        this.source = '';\n        /** The type of the current token, set in parse() */\n        this.type = '';\n        // Must be defined after `next()`\n        this.lexer = new Lexer();\n        this.onNewLine = onNewLine;\n    }\n    /**\n     * Parse `source` as a YAML stream.\n     * If `incomplete`, a part of the last line may be left as a buffer for the next call.\n     *\n     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.\n     *\n     * @returns A generator of tokens representing each directive, document, and other structure.\n     */\n    *parse(source, incomplete = false) {\n        if (this.onNewLine && this.offset === 0)\n            this.onNewLine(0);\n        for (const lexeme of this.lexer.lex(source, incomplete))\n            yield* this.next(lexeme);\n        if (!incomplete)\n            yield* this.end();\n    }\n    /**\n     * Advance the parser by the `source` of one lexical token.\n     */\n    *next(source) {\n        this.source = source;\n        if (this.atScalar) {\n            this.atScalar = false;\n            yield* this.step();\n            this.offset += source.length;\n            return;\n        }\n        const type = tokenType(source);\n        if (!type) {\n            const message = `Not a YAML token: ${source}`;\n            yield* this.pop({ type: 'error', offset: this.offset, message, source });\n            this.offset += source.length;\n        }\n        else if (type === 'scalar') {\n            this.atNewLine = false;\n            this.atScalar = true;\n            this.type = 'scalar';\n        }\n        else {\n            this.type = type;\n            yield* this.step();\n            switch (type) {\n                case 'newline':\n                    this.atNewLine = true;\n                    this.indent = 0;\n                    if (this.onNewLine)\n                        this.onNewLine(this.offset + source.length);\n                    break;\n                case 'space':\n                    if (this.atNewLine && source[0] === ' ')\n                        this.indent += source.length;\n                    break;\n                case 'explicit-key-ind':\n                case 'map-value-ind':\n                case 'seq-item-ind':\n                    if (this.atNewLine)\n                        this.indent += source.length;\n                    break;\n                case 'doc-mode':\n                case 'flow-error-end':\n                    return;\n                default:\n                    this.atNewLine = false;\n            }\n            this.offset += source.length;\n        }\n    }\n    /** Call at end of input to push out any remaining constructions */\n    *end() {\n        while (this.stack.length > 0)\n            yield* this.pop();\n    }\n    get sourceToken() {\n        const st = {\n            type: this.type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n        return st;\n    }\n    *step() {\n        const top = this.peek(1);\n        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {\n            while (this.stack.length > 0)\n                yield* this.pop();\n            this.stack.push({\n                type: 'doc-end',\n                offset: this.offset,\n                source: this.source\n            });\n            return;\n        }\n        if (!top)\n            return yield* this.stream();\n        switch (top.type) {\n            case 'document':\n                return yield* this.document(top);\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return yield* this.scalar(top);\n            case 'block-scalar':\n                return yield* this.blockScalar(top);\n            case 'block-map':\n                return yield* this.blockMap(top);\n            case 'block-seq':\n                return yield* this.blockSequence(top);\n            case 'flow-collection':\n                return yield* this.flowCollection(top);\n            case 'doc-end':\n                return yield* this.documentEnd(top);\n        }\n        /* istanbul ignore next should not happen */\n        yield* this.pop();\n    }\n    peek(n) {\n        return this.stack[this.stack.length - n];\n    }\n    *pop(error) {\n        const token = error ?? this.stack.pop();\n        /* istanbul ignore if should not happen */\n        if (!token) {\n            const message = 'Tried to pop an empty stack';\n            yield { type: 'error', offset: this.offset, source: '', message };\n        }\n        else if (this.stack.length === 0) {\n            yield token;\n        }\n        else {\n            const top = this.peek(1);\n            if (token.type === 'block-scalar') {\n                // Block scalars use their parent rather than header indent\n                token.indent = 'indent' in top ? top.indent : 0;\n            }\n            else if (token.type === 'flow-collection' && top.type === 'document') {\n                // Ignore all indent for top-level flow collections\n                token.indent = 0;\n            }\n            if (token.type === 'flow-collection')\n                fixFlowSeqItems(token);\n            switch (top.type) {\n                case 'document':\n                    top.value = token;\n                    break;\n                case 'block-scalar':\n                    top.props.push(token); // error\n                    break;\n                case 'block-map': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value) {\n                        top.items.push({ start: [], key: token, sep: [] });\n                        this.onKeyLine = true;\n                        return;\n                    }\n                    else if (it.sep) {\n                        it.value = token;\n                    }\n                    else {\n                        Object.assign(it, { key: token, sep: [] });\n                        this.onKeyLine = !includesToken(it.start, 'explicit-key-ind');\n                        return;\n                    }\n                    break;\n                }\n                case 'block-seq': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value)\n                        top.items.push({ start: [], value: token });\n                    else\n                        it.value = token;\n                    break;\n                }\n                case 'flow-collection': {\n                    const it = top.items[top.items.length - 1];\n                    if (!it || it.value)\n                        top.items.push({ start: [], key: token, sep: [] });\n                    else if (it.sep)\n                        it.value = token;\n                    else\n                        Object.assign(it, { key: token, sep: [] });\n                    return;\n                }\n                /* istanbul ignore next should not happen */\n                default:\n                    yield* this.pop();\n                    yield* this.pop(token);\n            }\n            if ((top.type === 'document' ||\n                top.type === 'block-map' ||\n                top.type === 'block-seq') &&\n                (token.type === 'block-map' || token.type === 'block-seq')) {\n                const last = token.items[token.items.length - 1];\n                if (last &&\n                    !last.sep &&\n                    !last.value &&\n                    last.start.length > 0 &&\n                    findNonEmptyIndex(last.start) === -1 &&\n                    (token.indent === 0 ||\n                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {\n                    if (top.type === 'document')\n                        top.end = last.start;\n                    else\n                        top.items.push({ start: last.start });\n                    token.items.splice(-1, 1);\n                }\n            }\n        }\n    }\n    *stream() {\n        switch (this.type) {\n            case 'directive-line':\n                yield { type: 'directive', offset: this.offset, source: this.source };\n                return;\n            case 'byte-order-mark':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                yield this.sourceToken;\n                return;\n            case 'doc-mode':\n            case 'doc-start': {\n                const doc = {\n                    type: 'document',\n                    offset: this.offset,\n                    start: []\n                };\n                if (this.type === 'doc-start')\n                    doc.start.push(this.sourceToken);\n                this.stack.push(doc);\n                return;\n            }\n        }\n        yield {\n            type: 'error',\n            offset: this.offset,\n            message: `Unexpected ${this.type} token in YAML stream`,\n            source: this.source\n        };\n    }\n    *document(doc) {\n        if (doc.value)\n            return yield* this.lineEnd(doc);\n        switch (this.type) {\n            case 'doc-start': {\n                if (findNonEmptyIndex(doc.start) !== -1) {\n                    yield* this.pop();\n                    yield* this.step();\n                }\n                else\n                    doc.start.push(this.sourceToken);\n                return;\n            }\n            case 'anchor':\n            case 'tag':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                doc.start.push(this.sourceToken);\n                return;\n        }\n        const bv = this.startBlockValue(doc);\n        if (bv)\n            this.stack.push(bv);\n        else {\n            yield {\n                type: 'error',\n                offset: this.offset,\n                message: `Unexpected ${this.type} token in YAML document`,\n                source: this.source\n            };\n        }\n    }\n    *scalar(scalar) {\n        if (this.type === 'map-value-ind') {\n            const prev = getPrevProps(this.peek(2));\n            const start = getFirstKeyStartProps(prev);\n            let sep;\n            if (scalar.end) {\n                sep = scalar.end;\n                sep.push(this.sourceToken);\n                delete scalar.end;\n            }\n            else\n                sep = [this.sourceToken];\n            const map = {\n                type: 'block-map',\n                offset: scalar.offset,\n                indent: scalar.indent,\n                items: [{ start, key: scalar, sep }]\n            };\n            this.onKeyLine = true;\n            this.stack[this.stack.length - 1] = map;\n        }\n        else\n            yield* this.lineEnd(scalar);\n    }\n    *blockScalar(scalar) {\n        switch (this.type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                scalar.props.push(this.sourceToken);\n                return;\n            case 'scalar':\n                scalar.source = this.source;\n                // block-scalar source includes trailing newline\n                this.atNewLine = true;\n                this.indent = 0;\n                if (this.onNewLine) {\n                    let nl = this.source.indexOf('\\n') + 1;\n                    while (nl !== 0) {\n                        this.onNewLine(this.offset + nl);\n                        nl = this.source.indexOf('\\n', nl) + 1;\n                    }\n                }\n                yield* this.pop();\n                break;\n            /* istanbul ignore next should not happen */\n            default:\n                yield* this.pop();\n                yield* this.step();\n        }\n    }\n    *blockMap(map) {\n        const it = map.items[map.items.length - 1];\n        // it.sep is true-ish if pair already has key or : separator\n        switch (this.type) {\n            case 'newline':\n                this.onKeyLine = false;\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value) {\n                    map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    if (this.atIndentedComment(it.start, map.indent)) {\n                        const prev = map.items[map.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            map.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n        }\n        if (this.indent >= map.indent) {\n            const atNextItem = !this.onKeyLine && this.indent === map.indent && it.sep;\n            // For empty nodes, assign newline-separated not indented empty tokens to following node\n            let start = [];\n            if (atNextItem && it.sep && !it.value) {\n                const nl = [];\n                for (let i = 0; i < it.sep.length; ++i) {\n                    const st = it.sep[i];\n                    switch (st.type) {\n                        case 'newline':\n                            nl.push(i);\n                            break;\n                        case 'space':\n                            break;\n                        case 'comment':\n                            if (st.indent > map.indent)\n                                nl.length = 0;\n                            break;\n                        default:\n                            nl.length = 0;\n                    }\n                }\n                if (nl.length >= 2)\n                    start = it.sep.splice(nl[1]);\n            }\n            switch (this.type) {\n                case 'anchor':\n                case 'tag':\n                    if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        it.sep.push(this.sourceToken);\n                    }\n                    else {\n                        it.start.push(this.sourceToken);\n                    }\n                    return;\n                case 'explicit-key-ind':\n                    if (!it.sep && !includesToken(it.start, 'explicit-key-ind')) {\n                        it.start.push(this.sourceToken);\n                    }\n                    else if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start });\n                    }\n                    else {\n                        this.stack.push({\n                            type: 'block-map',\n                            offset: this.offset,\n                            indent: this.indent,\n                            items: [{ start: [this.sourceToken] }]\n                        });\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'map-value-ind':\n                    if (includesToken(it.start, 'explicit-key-ind')) {\n                        if (!it.sep) {\n                            if (includesToken(it.start, 'newline')) {\n                                Object.assign(it, { key: null, sep: [this.sourceToken] });\n                            }\n                            else {\n                                const start = getFirstKeyStartProps(it.start);\n                                this.stack.push({\n                                    type: 'block-map',\n                                    offset: this.offset,\n                                    indent: this.indent,\n                                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                                });\n                            }\n                        }\n                        else if (it.value) {\n                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else if (isFlowToken(it.key) &&\n                            !includesToken(it.sep, 'newline')) {\n                            const start = getFirstKeyStartProps(it.start);\n                            const key = it.key;\n                            const sep = it.sep;\n                            sep.push(this.sourceToken);\n                            // @ts-expect-error type guard is wrong here\n                            delete it.key, delete it.sep;\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key, sep }]\n                            });\n                        }\n                        else if (start.length > 0) {\n                            // Not actually at next item\n                            it.sep = it.sep.concat(start, this.sourceToken);\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    else {\n                        if (!it.sep) {\n                            Object.assign(it, { key: null, sep: [this.sourceToken] });\n                        }\n                        else if (it.value || atNextItem) {\n                            map.items.push({ start, key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start: [], key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (atNextItem || it.value) {\n                        map.items.push({ start, key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        this.stack.push(fs);\n                    }\n                    else {\n                        Object.assign(it, { key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    return;\n                }\n                default: {\n                    const bv = this.startBlockValue(map);\n                    if (bv) {\n                        if (atNextItem &&\n                            bv.type !== 'block-seq' &&\n                            includesToken(it.start, 'explicit-key-ind')) {\n                            map.items.push({ start });\n                        }\n                        this.stack.push(bv);\n                        return;\n                    }\n                }\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *blockSequence(seq) {\n        const it = seq.items[seq.items.length - 1];\n        switch (this.type) {\n            case 'newline':\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        seq.items.push({ start: [this.sourceToken] });\n                }\n                else\n                    it.start.push(this.sourceToken);\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value)\n                    seq.items.push({ start: [this.sourceToken] });\n                else {\n                    if (this.atIndentedComment(it.start, seq.indent)) {\n                        const prev = seq.items[seq.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            seq.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'anchor':\n            case 'tag':\n                if (it.value || this.indent <= seq.indent)\n                    break;\n                it.start.push(this.sourceToken);\n                return;\n            case 'seq-item-ind':\n                if (this.indent !== seq.indent)\n                    break;\n                if (it.value || includesToken(it.start, 'seq-item-ind'))\n                    seq.items.push({ start: [this.sourceToken] });\n                else\n                    it.start.push(this.sourceToken);\n                return;\n        }\n        if (this.indent > seq.indent) {\n            const bv = this.startBlockValue(seq);\n            if (bv) {\n                this.stack.push(bv);\n                return;\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *flowCollection(fc) {\n        const it = fc.items[fc.items.length - 1];\n        if (this.type === 'flow-error-end') {\n            let top;\n            do {\n                yield* this.pop();\n                top = this.peek(1);\n            } while (top && top.type === 'flow-collection');\n        }\n        else if (fc.end.length === 0) {\n            switch (this.type) {\n                case 'comma':\n                case 'explicit-key-ind':\n                    if (!it || it.sep)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'map-value-ind':\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        Object.assign(it, { key: null, sep: [this.sourceToken] });\n                    return;\n                case 'space':\n                case 'comment':\n                case 'newline':\n                case 'anchor':\n                case 'tag':\n                    if (!it || it.value)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: fs, sep: [] });\n                    else if (it.sep)\n                        this.stack.push(fs);\n                    else\n                        Object.assign(it, { key: fs, sep: [] });\n                    return;\n                }\n                case 'flow-map-end':\n                case 'flow-seq-end':\n                    fc.end.push(this.sourceToken);\n                    return;\n            }\n            const bv = this.startBlockValue(fc);\n            /* istanbul ignore else should not happen */\n            if (bv)\n                this.stack.push(bv);\n            else {\n                yield* this.pop();\n                yield* this.step();\n            }\n        }\n        else {\n            const parent = this.peek(2);\n            if (parent.type === 'block-map' &&\n                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||\n                    (this.type === 'newline' &&\n                        !parent.items[parent.items.length - 1].sep))) {\n                yield* this.pop();\n                yield* this.step();\n            }\n            else if (this.type === 'map-value-ind' &&\n                parent.type !== 'flow-collection') {\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                fixFlowSeqItems(fc);\n                const sep = fc.end.splice(1, fc.end.length);\n                sep.push(this.sourceToken);\n                const map = {\n                    type: 'block-map',\n                    offset: fc.offset,\n                    indent: fc.indent,\n                    items: [{ start, key: fc, sep }]\n                };\n                this.onKeyLine = true;\n                this.stack[this.stack.length - 1] = map;\n            }\n            else {\n                yield* this.lineEnd(fc);\n            }\n        }\n    }\n    flowScalar(type) {\n        if (this.onNewLine) {\n            let nl = this.source.indexOf('\\n') + 1;\n            while (nl !== 0) {\n                this.onNewLine(this.offset + nl);\n                nl = this.source.indexOf('\\n', nl) + 1;\n            }\n        }\n        return {\n            type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n    }\n    startBlockValue(parent) {\n        switch (this.type) {\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return this.flowScalar(this.type);\n            case 'block-scalar-header':\n                return {\n                    type: 'block-scalar',\n                    offset: this.offset,\n                    indent: this.indent,\n                    props: [this.sourceToken],\n                    source: ''\n                };\n            case 'flow-map-start':\n            case 'flow-seq-start':\n                return {\n                    type: 'flow-collection',\n                    offset: this.offset,\n                    indent: this.indent,\n                    start: this.sourceToken,\n                    items: [],\n                    end: []\n                };\n            case 'seq-item-ind':\n                return {\n                    type: 'block-seq',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start: [this.sourceToken] }]\n                };\n            case 'explicit-key-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                start.push(this.sourceToken);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start }]\n                };\n            }\n            case 'map-value-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                };\n            }\n        }\n        return null;\n    }\n    atIndentedComment(start, indent) {\n        if (this.type !== 'comment')\n            return false;\n        if (this.indent <= indent)\n            return false;\n        return start.every(st => st.type === 'newline' || st.type === 'space');\n    }\n    *documentEnd(docEnd) {\n        if (this.type !== 'doc-mode') {\n            if (docEnd.end)\n                docEnd.end.push(this.sourceToken);\n            else\n                docEnd.end = [this.sourceToken];\n            if (this.type === 'newline')\n                yield* this.pop();\n        }\n    }\n    *lineEnd(token) {\n        switch (this.type) {\n            case 'comma':\n            case 'doc-start':\n            case 'doc-end':\n            case 'flow-seq-end':\n            case 'flow-map-end':\n            case 'map-value-ind':\n                yield* this.pop();\n                yield* this.step();\n                break;\n            case 'newline':\n                this.onKeyLine = false;\n            // fallthrough\n            case 'space':\n            case 'comment':\n            default:\n                // all other values are errors\n                if (token.end)\n                    token.end.push(this.sourceToken);\n                else\n                    token.end = [this.sourceToken];\n                if (this.type === 'newline')\n                    yield* this.pop();\n        }\n    }\n}\n\nexport { Parser };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}