{"ast":null,"code":"import { isNode } from '../nodes/identity.js';\nimport { Scalar } from '../nodes/Scalar.js';\nimport { YAMLMap } from '../nodes/YAMLMap.js';\nimport { YAMLSeq } from '../nodes/YAMLSeq.js';\nimport { resolveBlockMap } from './resolve-block-map.js';\nimport { resolveBlockSeq } from './resolve-block-seq.js';\nimport { resolveFlowCollection } from './resolve-flow-collection.js';\nfunction resolveCollection(CN, ctx, token, onError, tagName, tag) {\n  const coll = token.type === 'block-map' ? resolveBlockMap(CN, ctx, token, onError, tag) : token.type === 'block-seq' ? resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection(CN, ctx, token, onError, tag);\n  const Coll = coll.constructor;\n  // If we got a tagName matching the class, or the tag name is '!',\n  // then use the tagName from the node class used to create it.\n  if (tagName === '!' || tagName === Coll.tagName) {\n    coll.tag = Coll.tagName;\n    return coll;\n  }\n  if (tagName) coll.tag = tagName;\n  return coll;\n}\nfunction composeCollection(CN, ctx, token, tagToken, onError) {\n  const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));\n  const expType = token.type === 'block-map' ? 'map' : token.type === 'block-seq' ? 'seq' : token.start.source === '{' ? 'map' : 'seq';\n  // shortcut: check if it's a generic YAMLMap or YAMLSeq\n  // before jumping into the custom tag logic.\n  if (!tagToken || !tagName || tagName === '!' || tagName === YAMLMap.tagName && expType === 'map' || tagName === YAMLSeq.tagName && expType === 'seq' || !expType) {\n    return resolveCollection(CN, ctx, token, onError, tagName);\n  }\n  let tag = ctx.schema.tags.find(t => t.tag === tagName && t.collection === expType);\n  if (!tag) {\n    const kt = ctx.schema.knownTags[tagName];\n    if (kt && kt.collection === expType) {\n      ctx.schema.tags.push(Object.assign({}, kt, {\n        default: false\n      }));\n      tag = kt;\n    } else {\n      if (kt?.collection) {\n        onError(tagToken, 'BAD_COLLECTION_TYPE', `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);\n      } else {\n        onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);\n      }\n      return resolveCollection(CN, ctx, token, onError, tagName);\n    }\n  }\n  const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);\n  const res = tag.resolve?.(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options) ?? coll;\n  const node = isNode(res) ? res : new Scalar(res);\n  node.range = coll.range;\n  node.tag = tagName;\n  if (tag?.format) node.format = tag.format;\n  return node;\n}\nexport { composeCollection };","map":{"version":3,"names":["isNode","Scalar","YAMLMap","YAMLSeq","resolveBlockMap","resolveBlockSeq","resolveFlowCollection","resolveCollection","CN","ctx","token","onError","tagName","tag","coll","type","Coll","constructor","composeCollection","tagToken","directives","source","msg","expType","start","schema","tags","find","t","collection","kt","knownTags","push","Object","assign","default","res","resolve","options","node","range","format"],"sources":["/Users/shoukaiwen/WebstormProjects/alluxio-k8s-operator-ui/node_modules/yaml/browser/dist/compose/compose-collection.js"],"sourcesContent":["import { isNode } from '../nodes/identity.js';\nimport { Scalar } from '../nodes/Scalar.js';\nimport { YAMLMap } from '../nodes/YAMLMap.js';\nimport { YAMLSeq } from '../nodes/YAMLSeq.js';\nimport { resolveBlockMap } from './resolve-block-map.js';\nimport { resolveBlockSeq } from './resolve-block-seq.js';\nimport { resolveFlowCollection } from './resolve-flow-collection.js';\n\nfunction resolveCollection(CN, ctx, token, onError, tagName, tag) {\n    const coll = token.type === 'block-map'\n        ? resolveBlockMap(CN, ctx, token, onError, tag)\n        : token.type === 'block-seq'\n            ? resolveBlockSeq(CN, ctx, token, onError, tag)\n            : resolveFlowCollection(CN, ctx, token, onError, tag);\n    const Coll = coll.constructor;\n    // If we got a tagName matching the class, or the tag name is '!',\n    // then use the tagName from the node class used to create it.\n    if (tagName === '!' || tagName === Coll.tagName) {\n        coll.tag = Coll.tagName;\n        return coll;\n    }\n    if (tagName)\n        coll.tag = tagName;\n    return coll;\n}\nfunction composeCollection(CN, ctx, token, tagToken, onError) {\n    const tagName = !tagToken\n        ? null\n        : ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));\n    const expType = token.type === 'block-map'\n        ? 'map'\n        : token.type === 'block-seq'\n            ? 'seq'\n            : token.start.source === '{'\n                ? 'map'\n                : 'seq';\n    // shortcut: check if it's a generic YAMLMap or YAMLSeq\n    // before jumping into the custom tag logic.\n    if (!tagToken ||\n        !tagName ||\n        tagName === '!' ||\n        (tagName === YAMLMap.tagName && expType === 'map') ||\n        (tagName === YAMLSeq.tagName && expType === 'seq') ||\n        !expType) {\n        return resolveCollection(CN, ctx, token, onError, tagName);\n    }\n    let tag = ctx.schema.tags.find(t => t.tag === tagName && t.collection === expType);\n    if (!tag) {\n        const kt = ctx.schema.knownTags[tagName];\n        if (kt && kt.collection === expType) {\n            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));\n            tag = kt;\n        }\n        else {\n            if (kt?.collection) {\n                onError(tagToken, 'BAD_COLLECTION_TYPE', `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);\n            }\n            else {\n                onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);\n            }\n            return resolveCollection(CN, ctx, token, onError, tagName);\n        }\n    }\n    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);\n    const res = tag.resolve?.(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options) ?? coll;\n    const node = isNode(res)\n        ? res\n        : new Scalar(res);\n    node.range = coll.range;\n    node.tag = tagName;\n    if (tag?.format)\n        node.format = tag.format;\n    return node;\n}\n\nexport { composeCollection };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}