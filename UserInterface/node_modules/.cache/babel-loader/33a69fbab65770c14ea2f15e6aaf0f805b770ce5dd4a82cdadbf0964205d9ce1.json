{"ast":null,"code":"/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('parse5').ParserError} ParserError\n * @typedef {import('vfile').Value} Value\n */\n\n/**\n * @typedef {keyof errors} ErrorCode\n *   Known names of parse errors.\n *\n * @typedef {Partial<Record<ErrorCode, ErrorSeverity | null | undefined>>} ErrorOptions\n *   Options that define the severity of errors.\n *\n * @typedef {boolean | 0 | 1 | 2} ErrorSeverity\n *   Error severity:\n *\n *   * `0` or `false`\n *     â€” turn the parse error off\n *   * `1` or `true`\n *     â€” turn the parse error into a warning\n *   * `2`\n *     â€” turn the parse error into an actual error: processing stops.\n *\n * @typedef ExtraOptions\n *   Options that define how to parse HTML.\n * @property {boolean | null | undefined} [fragment=false]\n *   Specify whether to parse a fragment, instead of a complete document\n *   (default: `false`).\n *\n *   In document mode, unopened `html`, `head`, and `body` elements are opened\n *   in just the right places.\n * @property {OnError | null | undefined} [onerror]\n *   Call `onerror` with parse errors while parsing (optional).\n *\n *   > ðŸ‘‰ **Note**: parse errors are currently being added to HTML.\n *   > Not all errors emitted by parse5 (or us) are specced yet.\n *   > Some documentation may still be missing.\n *\n *   Specific rules can be turned off by setting them to `false` (or `0`).\n *   The default, when `emitParseErrors: true`, is `true` (or `1`), and means\n *   that rules emit as warnings.\n *   Rules can also be configured with `2`, to turn them into fatal errors.\n *\n * @typedef {Omit<import('hast-util-from-parse5').Options, 'file'>} FromParse5Options\n *   Options that can be passed through to `hast-util-from-parse5`.\n *\n * @callback OnError\n *   Handle parse errors.\n * @param {VFileMessage} error\n *   Message.\n * @returns {undefined | void}\n *   Nothing.\n *\n *   Note: `void` included until TS infers `undefined` nicely.\n *\n * @typedef {FromParse5Options & ErrorOptions & ExtraOptions} Options\n *   Configuration.\n */\n\nimport { ok as assert } from 'devlop';\nimport { fromParse5 } from 'hast-util-from-parse5';\nimport { parse, parseFragment } from 'parse5';\nimport { VFile } from 'vfile';\nimport { VFileMessage } from 'vfile-message';\nimport { errors } from './errors.js';\nconst base = 'https://html.spec.whatwg.org/multipage/parsing.html#parse-error-';\nconst dashToCamelRe = /-[a-z]/g;\nconst formatCRe = /%c(?:([-+])(\\d+))?/g;\nconst formatXRe = /%x/g;\nconst fatalities = {\n  2: true,\n  1: false,\n  0: null\n};\n\n/** @type {Readonly<Options>} */\nconst emptyOptions = {};\n\n/**\n * Turn serialized HTML into a hast tree.\n *\n * @param {VFile | Value} value\n *   Serialized HTML to parse.\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {Root}\n *   Tree.\n */\nexport function fromHtml(value, options) {\n  const settings = options || emptyOptions;\n  const onerror = settings.onerror;\n  const file = value instanceof VFile ? value : new VFile(value);\n  const fn = settings.fragment ? parseFragment : parse;\n  const doc = String(file);\n  const p5doc = fn(doc, {\n    sourceCodeLocationInfo: true,\n    // Note `parse5` types currently do not allow `undefined`.\n    onParseError: settings.onerror ? internalOnerror : null,\n    scriptingEnabled: false\n  });\n\n  // `parse5` returns document which are always mapped to roots.\n  return /** @type {Root} */(\n    fromParse5(p5doc, {\n      file,\n      space: settings.space,\n      verbose: settings.verbose\n    })\n  );\n\n  /**\n   * Handle a parse error.\n   *\n   * @param {ParserError} error\n   *   Parse5 error.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function internalOnerror(error) {\n    const code = error.code;\n    const name = camelcase(code);\n    const setting = settings[name];\n    const config = setting === null || setting === undefined ? true : setting;\n    const level = typeof config === 'number' ? config : config ? 1 : 0;\n    if (level) {\n      const info = errors[name];\n      assert(info, 'expected known error from `parse5`');\n      const message = new VFileMessage(format(info.reason), {\n        place: {\n          start: {\n            line: error.startLine,\n            column: error.startCol,\n            offset: error.startOffset\n          },\n          end: {\n            line: error.endLine,\n            column: error.endCol,\n            offset: error.endOffset\n          }\n        },\n        ruleId: code,\n        source: 'hast-util-from-html'\n      });\n      if (file.path) {\n        message.file = file.path;\n        message.name = file.path + ':' + message.name;\n      }\n      message.fatal = fatalities[level];\n      message.note = format(info.description);\n      message.url = info.url === false ? undefined : base + code;\n      assert(onerror, '`internalOnerror` is not passed if `onerror` is not set');\n      onerror(message);\n    }\n\n    /**\n     * Format a human readable string about an error.\n     *\n     * @param {string} value\n     *   Value to format.\n     * @returns {string}\n     *   Formatted.\n     */\n    function format(value) {\n      return value.replace(formatCRe, formatC).replace(formatXRe, formatX);\n\n      /**\n       * Format the character.\n       *\n       * @param {string} _\n       *   Match.\n       * @param {string} $1\n       *   Sign (`-` or `+`, optional).\n       * @param {string} $2\n       *   Offset.\n       * @returns {string}\n       *   Formatted.\n       */\n      function formatC(_, $1, $2) {\n        const offset = ($2 ? Number.parseInt($2, 10) : 0) * ($1 === '-' ? -1 : 1);\n        const char = doc.charAt(error.startOffset + offset);\n        return visualizeCharacter(char);\n      }\n\n      /**\n       * Format the character code.\n       *\n       * @returns {string}\n       *   Formatted.\n       */\n      function formatX() {\n        return visualizeCharacterCode(doc.charCodeAt(error.startOffset));\n      }\n    }\n  }\n}\n\n/**\n * @param {string} value\n *   Error code in dash case.\n * @returns {ErrorCode}\n *   Error code in camelcase.\n */\nfunction camelcase(value) {\n  // This should match an error code.\n  return /** @type {ErrorCode} */value.replace(dashToCamelRe, dashToCamel);\n}\n\n/**\n * @param {string} $0\n *   Match.\n * @returns {string}\n *   Camelcased.\n */\nfunction dashToCamel($0) {\n  return $0.charAt(1).toUpperCase();\n}\n\n/**\n * @param {string} char\n *   Character.\n * @returns {string}\n *   Formatted.\n */\nfunction visualizeCharacter(char) {\n  return char === '`' ? '` ` `' : char;\n}\n\n/**\n * @param {number} charCode\n *   Character code.\n * @returns {string}\n *   Formatted.\n */\nfunction visualizeCharacterCode(charCode) {\n  return '0x' + charCode.toString(16).toUpperCase();\n}","map":{"version":3,"names":["ok","assert","fromParse5","parse","parseFragment","VFile","VFileMessage","errors","base","dashToCamelRe","formatCRe","formatXRe","fatalities","emptyOptions","fromHtml","value","options","settings","onerror","file","fn","fragment","doc","String","p5doc","sourceCodeLocationInfo","onParseError","internalOnerror","scriptingEnabled","space","verbose","error","code","name","camelcase","setting","config","undefined","level","info","message","format","reason","place","start","line","startLine","column","startCol","offset","startOffset","end","endLine","endCol","endOffset","ruleId","source","path","fatal","note","description","url","replace","formatC","formatX","_","$1","$2","Number","parseInt","char","charAt","visualizeCharacter","visualizeCharacterCode","charCodeAt","dashToCamel","$0","toUpperCase","charCode","toString"],"sources":["/Users/shoukaiwen/WebstormProjects/alluxio-k8s-operator-ui/node_modules/hast-util-from-html/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('parse5').ParserError} ParserError\n * @typedef {import('vfile').Value} Value\n */\n\n/**\n * @typedef {keyof errors} ErrorCode\n *   Known names of parse errors.\n *\n * @typedef {Partial<Record<ErrorCode, ErrorSeverity | null | undefined>>} ErrorOptions\n *   Options that define the severity of errors.\n *\n * @typedef {boolean | 0 | 1 | 2} ErrorSeverity\n *   Error severity:\n *\n *   * `0` or `false`\n *     â€” turn the parse error off\n *   * `1` or `true`\n *     â€” turn the parse error into a warning\n *   * `2`\n *     â€” turn the parse error into an actual error: processing stops.\n *\n * @typedef ExtraOptions\n *   Options that define how to parse HTML.\n * @property {boolean | null | undefined} [fragment=false]\n *   Specify whether to parse a fragment, instead of a complete document\n *   (default: `false`).\n *\n *   In document mode, unopened `html`, `head`, and `body` elements are opened\n *   in just the right places.\n * @property {OnError | null | undefined} [onerror]\n *   Call `onerror` with parse errors while parsing (optional).\n *\n *   > ðŸ‘‰ **Note**: parse errors are currently being added to HTML.\n *   > Not all errors emitted by parse5 (or us) are specced yet.\n *   > Some documentation may still be missing.\n *\n *   Specific rules can be turned off by setting them to `false` (or `0`).\n *   The default, when `emitParseErrors: true`, is `true` (or `1`), and means\n *   that rules emit as warnings.\n *   Rules can also be configured with `2`, to turn them into fatal errors.\n *\n * @typedef {Omit<import('hast-util-from-parse5').Options, 'file'>} FromParse5Options\n *   Options that can be passed through to `hast-util-from-parse5`.\n *\n * @callback OnError\n *   Handle parse errors.\n * @param {VFileMessage} error\n *   Message.\n * @returns {undefined | void}\n *   Nothing.\n *\n *   Note: `void` included until TS infers `undefined` nicely.\n *\n * @typedef {FromParse5Options & ErrorOptions & ExtraOptions} Options\n *   Configuration.\n */\n\nimport {ok as assert} from 'devlop'\nimport {fromParse5} from 'hast-util-from-parse5'\nimport {parse, parseFragment} from 'parse5'\nimport {VFile} from 'vfile'\nimport {VFileMessage} from 'vfile-message'\nimport {errors} from './errors.js'\n\nconst base = 'https://html.spec.whatwg.org/multipage/parsing.html#parse-error-'\n\nconst dashToCamelRe = /-[a-z]/g\nconst formatCRe = /%c(?:([-+])(\\d+))?/g\nconst formatXRe = /%x/g\n\nconst fatalities = {2: true, 1: false, 0: null}\n\n/** @type {Readonly<Options>} */\nconst emptyOptions = {}\n\n/**\n * Turn serialized HTML into a hast tree.\n *\n * @param {VFile | Value} value\n *   Serialized HTML to parse.\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {Root}\n *   Tree.\n */\nexport function fromHtml(value, options) {\n  const settings = options || emptyOptions\n  const onerror = settings.onerror\n  const file = value instanceof VFile ? value : new VFile(value)\n  const fn = settings.fragment ? parseFragment : parse\n  const doc = String(file)\n  const p5doc = fn(doc, {\n    sourceCodeLocationInfo: true,\n    // Note `parse5` types currently do not allow `undefined`.\n    onParseError: settings.onerror ? internalOnerror : null,\n    scriptingEnabled: false\n  })\n\n  // `parse5` returns document which are always mapped to roots.\n  return /** @type {Root} */ (\n    fromParse5(p5doc, {\n      file,\n      space: settings.space,\n      verbose: settings.verbose\n    })\n  )\n\n  /**\n   * Handle a parse error.\n   *\n   * @param {ParserError} error\n   *   Parse5 error.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function internalOnerror(error) {\n    const code = error.code\n    const name = camelcase(code)\n    const setting = settings[name]\n    const config = setting === null || setting === undefined ? true : setting\n    const level = typeof config === 'number' ? config : config ? 1 : 0\n\n    if (level) {\n      const info = errors[name]\n      assert(info, 'expected known error from `parse5`')\n\n      const message = new VFileMessage(format(info.reason), {\n        place: {\n          start: {\n            line: error.startLine,\n            column: error.startCol,\n            offset: error.startOffset\n          },\n          end: {\n            line: error.endLine,\n            column: error.endCol,\n            offset: error.endOffset\n          }\n        },\n        ruleId: code,\n        source: 'hast-util-from-html'\n      })\n\n      if (file.path) {\n        message.file = file.path\n        message.name = file.path + ':' + message.name\n      }\n\n      message.fatal = fatalities[level]\n      message.note = format(info.description)\n      message.url = info.url === false ? undefined : base + code\n\n      assert(onerror, '`internalOnerror` is not passed if `onerror` is not set')\n      onerror(message)\n    }\n\n    /**\n     * Format a human readable string about an error.\n     *\n     * @param {string} value\n     *   Value to format.\n     * @returns {string}\n     *   Formatted.\n     */\n    function format(value) {\n      return value.replace(formatCRe, formatC).replace(formatXRe, formatX)\n\n      /**\n       * Format the character.\n       *\n       * @param {string} _\n       *   Match.\n       * @param {string} $1\n       *   Sign (`-` or `+`, optional).\n       * @param {string} $2\n       *   Offset.\n       * @returns {string}\n       *   Formatted.\n       */\n      function formatC(_, $1, $2) {\n        const offset =\n          ($2 ? Number.parseInt($2, 10) : 0) * ($1 === '-' ? -1 : 1)\n        const char = doc.charAt(error.startOffset + offset)\n        return visualizeCharacter(char)\n      }\n\n      /**\n       * Format the character code.\n       *\n       * @returns {string}\n       *   Formatted.\n       */\n      function formatX() {\n        return visualizeCharacterCode(doc.charCodeAt(error.startOffset))\n      }\n    }\n  }\n}\n\n/**\n * @param {string} value\n *   Error code in dash case.\n * @returns {ErrorCode}\n *   Error code in camelcase.\n */\nfunction camelcase(value) {\n  // This should match an error code.\n  return /** @type {ErrorCode} */ (value.replace(dashToCamelRe, dashToCamel))\n}\n\n/**\n * @param {string} $0\n *   Match.\n * @returns {string}\n *   Camelcased.\n */\nfunction dashToCamel($0) {\n  return $0.charAt(1).toUpperCase()\n}\n\n/**\n * @param {string} char\n *   Character.\n * @returns {string}\n *   Formatted.\n */\nfunction visualizeCharacter(char) {\n  return char === '`' ? '` ` `' : char\n}\n\n/**\n * @param {number} charCode\n *   Character code.\n * @returns {string}\n *   Formatted.\n */\nfunction visualizeCharacterCode(charCode) {\n  return '0x' + charCode.toString(16).toUpperCase()\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}