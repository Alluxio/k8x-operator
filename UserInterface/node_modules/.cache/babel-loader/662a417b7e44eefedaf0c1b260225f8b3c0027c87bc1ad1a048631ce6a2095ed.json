{"ast":null,"code":"import { isDocument, isNode, isPair, isCollection, isMap, isSeq, isScalar, isAlias } from './nodes/identity.js';\nconst BREAK = Symbol('break visit');\nconst SKIP = Symbol('skip children');\nconst REMOVE = Symbol('remove node');\n/**\n * Apply a visitor to an AST node or document.\n *\n * Walks through the tree (depth-first) starting from `node`, calling a\n * `visitor` function with three arguments:\n *   - `key`: For sequence values and map `Pair`, the node's index in the\n *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.\n *     `null` for the root node.\n *   - `node`: The current node.\n *   - `path`: The ancestry of the current node.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this node, continue with next\n *     sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current node, then continue with the next one\n *   - `Node`: Replace the current node, then continue by visiting it\n *   - `number`: While iterating the items of a sequence or map, set the index\n *     of the next step. This is useful especially if the index of the current\n *     node has changed.\n *\n * If `visitor` is a single function, it will be called with all values\n * encountered in the tree, including e.g. `null` values. Alternatively,\n * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,\n * `Alias` and `Scalar` node. To define the same visitor function for more than\n * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)\n * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most\n * specific defined one will be used for each node.\n */\nfunction visit(node, visitor) {\n  const visitor_ = initVisitor(visitor);\n  if (isDocument(node)) {\n    const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));\n    if (cd === REMOVE) node.contents = null;\n  } else visit_(null, node, visitor_, Object.freeze([]));\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisit.BREAK = BREAK;\n/** Do not visit the children of the current node */\nvisit.SKIP = SKIP;\n/** Remove the current node */\nvisit.REMOVE = REMOVE;\nfunction visit_(key, node, visitor, path) {\n  const ctrl = callVisitor(key, node, visitor, path);\n  if (isNode(ctrl) || isPair(ctrl)) {\n    replaceNode(key, path, ctrl);\n    return visit_(key, ctrl, visitor, path);\n  }\n  if (typeof ctrl !== 'symbol') {\n    if (isCollection(node)) {\n      path = Object.freeze(path.concat(node));\n      for (let i = 0; i < node.items.length; ++i) {\n        const ci = visit_(i, node.items[i], visitor, path);\n        if (typeof ci === 'number') i = ci - 1;else if (ci === BREAK) return BREAK;else if (ci === REMOVE) {\n          node.items.splice(i, 1);\n          i -= 1;\n        }\n      }\n    } else if (isPair(node)) {\n      path = Object.freeze(path.concat(node));\n      const ck = visit_('key', node.key, visitor, path);\n      if (ck === BREAK) return BREAK;else if (ck === REMOVE) node.key = null;\n      const cv = visit_('value', node.value, visitor, path);\n      if (cv === BREAK) return BREAK;else if (cv === REMOVE) node.value = null;\n    }\n  }\n  return ctrl;\n}\n/**\n * Apply an async visitor to an AST node or document.\n *\n * Walks through the tree (depth-first) starting from `node`, calling a\n * `visitor` function with three arguments:\n *   - `key`: For sequence values and map `Pair`, the node's index in the\n *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.\n *     `null` for the root node.\n *   - `node`: The current node.\n *   - `path`: The ancestry of the current node.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `Promise`: Must resolve to one of the following values\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this node, continue with next\n *     sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current node, then continue with the next one\n *   - `Node`: Replace the current node, then continue by visiting it\n *   - `number`: While iterating the items of a sequence or map, set the index\n *     of the next step. This is useful especially if the index of the current\n *     node has changed.\n *\n * If `visitor` is a single function, it will be called with all values\n * encountered in the tree, including e.g. `null` values. Alternatively,\n * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,\n * `Alias` and `Scalar` node. To define the same visitor function for more than\n * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)\n * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most\n * specific defined one will be used for each node.\n */\nasync function visitAsync(node, visitor) {\n  const visitor_ = initVisitor(visitor);\n  if (isDocument(node)) {\n    const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));\n    if (cd === REMOVE) node.contents = null;\n  } else await visitAsync_(null, node, visitor_, Object.freeze([]));\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisitAsync.BREAK = BREAK;\n/** Do not visit the children of the current node */\nvisitAsync.SKIP = SKIP;\n/** Remove the current node */\nvisitAsync.REMOVE = REMOVE;\nasync function visitAsync_(key, node, visitor, path) {\n  const ctrl = await callVisitor(key, node, visitor, path);\n  if (isNode(ctrl) || isPair(ctrl)) {\n    replaceNode(key, path, ctrl);\n    return visitAsync_(key, ctrl, visitor, path);\n  }\n  if (typeof ctrl !== 'symbol') {\n    if (isCollection(node)) {\n      path = Object.freeze(path.concat(node));\n      for (let i = 0; i < node.items.length; ++i) {\n        const ci = await visitAsync_(i, node.items[i], visitor, path);\n        if (typeof ci === 'number') i = ci - 1;else if (ci === BREAK) return BREAK;else if (ci === REMOVE) {\n          node.items.splice(i, 1);\n          i -= 1;\n        }\n      }\n    } else if (isPair(node)) {\n      path = Object.freeze(path.concat(node));\n      const ck = await visitAsync_('key', node.key, visitor, path);\n      if (ck === BREAK) return BREAK;else if (ck === REMOVE) node.key = null;\n      const cv = await visitAsync_('value', node.value, visitor, path);\n      if (cv === BREAK) return BREAK;else if (cv === REMOVE) node.value = null;\n    }\n  }\n  return ctrl;\n}\nfunction initVisitor(visitor) {\n  if (typeof visitor === 'object' && (visitor.Collection || visitor.Node || visitor.Value)) {\n    return Object.assign({\n      Alias: visitor.Node,\n      Map: visitor.Node,\n      Scalar: visitor.Node,\n      Seq: visitor.Node\n    }, visitor.Value && {\n      Map: visitor.Value,\n      Scalar: visitor.Value,\n      Seq: visitor.Value\n    }, visitor.Collection && {\n      Map: visitor.Collection,\n      Seq: visitor.Collection\n    }, visitor);\n  }\n  return visitor;\n}\nfunction callVisitor(key, node, visitor, path) {\n  var _visitor$Map, _visitor$Seq, _visitor$Pair, _visitor$Scalar, _visitor$Alias;\n  if (typeof visitor === 'function') return visitor(key, node, path);\n  if (isMap(node)) return (_visitor$Map = visitor.Map) === null || _visitor$Map === void 0 ? void 0 : _visitor$Map.call(visitor, key, node, path);\n  if (isSeq(node)) return (_visitor$Seq = visitor.Seq) === null || _visitor$Seq === void 0 ? void 0 : _visitor$Seq.call(visitor, key, node, path);\n  if (isPair(node)) return (_visitor$Pair = visitor.Pair) === null || _visitor$Pair === void 0 ? void 0 : _visitor$Pair.call(visitor, key, node, path);\n  if (isScalar(node)) return (_visitor$Scalar = visitor.Scalar) === null || _visitor$Scalar === void 0 ? void 0 : _visitor$Scalar.call(visitor, key, node, path);\n  if (isAlias(node)) return (_visitor$Alias = visitor.Alias) === null || _visitor$Alias === void 0 ? void 0 : _visitor$Alias.call(visitor, key, node, path);\n  return undefined;\n}\nfunction replaceNode(key, path, node) {\n  const parent = path[path.length - 1];\n  if (isCollection(parent)) {\n    parent.items[key] = node;\n  } else if (isPair(parent)) {\n    if (key === 'key') parent.key = node;else parent.value = node;\n  } else if (isDocument(parent)) {\n    parent.contents = node;\n  } else {\n    const pt = isAlias(parent) ? 'alias' : 'scalar';\n    throw new Error(\"Cannot replace node with \".concat(pt, \" parent\"));\n  }\n}\nexport { visit, visitAsync };","map":{"version":3,"names":["isDocument","isNode","isPair","isCollection","isMap","isSeq","isScalar","isAlias","BREAK","Symbol","SKIP","REMOVE","visit","node","visitor","visitor_","initVisitor","cd","visit_","contents","Object","freeze","key","path","ctrl","callVisitor","replaceNode","concat","i","items","length","ci","splice","ck","cv","value","visitAsync","visitAsync_","Collection","Node","Value","assign","Alias","Map","Scalar","Seq","_visitor$Map","_visitor$Seq","_visitor$Pair","_visitor$Scalar","_visitor$Alias","call","Pair","undefined","parent","pt","Error"],"sources":["/Users/shoukaiwen/WebstormProjects/alluxio-k8s-operator-ui/node_modules/yaml/browser/dist/visit.js"],"sourcesContent":["import { isDocument, isNode, isPair, isCollection, isMap, isSeq, isScalar, isAlias } from './nodes/identity.js';\n\nconst BREAK = Symbol('break visit');\nconst SKIP = Symbol('skip children');\nconst REMOVE = Symbol('remove node');\n/**\n * Apply a visitor to an AST node or document.\n *\n * Walks through the tree (depth-first) starting from `node`, calling a\n * `visitor` function with three arguments:\n *   - `key`: For sequence values and map `Pair`, the node's index in the\n *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.\n *     `null` for the root node.\n *   - `node`: The current node.\n *   - `path`: The ancestry of the current node.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this node, continue with next\n *     sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current node, then continue with the next one\n *   - `Node`: Replace the current node, then continue by visiting it\n *   - `number`: While iterating the items of a sequence or map, set the index\n *     of the next step. This is useful especially if the index of the current\n *     node has changed.\n *\n * If `visitor` is a single function, it will be called with all values\n * encountered in the tree, including e.g. `null` values. Alternatively,\n * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,\n * `Alias` and `Scalar` node. To define the same visitor function for more than\n * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)\n * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most\n * specific defined one will be used for each node.\n */\nfunction visit(node, visitor) {\n    const visitor_ = initVisitor(visitor);\n    if (isDocument(node)) {\n        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));\n        if (cd === REMOVE)\n            node.contents = null;\n    }\n    else\n        visit_(null, node, visitor_, Object.freeze([]));\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisit.BREAK = BREAK;\n/** Do not visit the children of the current node */\nvisit.SKIP = SKIP;\n/** Remove the current node */\nvisit.REMOVE = REMOVE;\nfunction visit_(key, node, visitor, path) {\n    const ctrl = callVisitor(key, node, visitor, path);\n    if (isNode(ctrl) || isPair(ctrl)) {\n        replaceNode(key, path, ctrl);\n        return visit_(key, ctrl, visitor, path);\n    }\n    if (typeof ctrl !== 'symbol') {\n        if (isCollection(node)) {\n            path = Object.freeze(path.concat(node));\n            for (let i = 0; i < node.items.length; ++i) {\n                const ci = visit_(i, node.items[i], visitor, path);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    node.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n        }\n        else if (isPair(node)) {\n            path = Object.freeze(path.concat(node));\n            const ck = visit_('key', node.key, visitor, path);\n            if (ck === BREAK)\n                return BREAK;\n            else if (ck === REMOVE)\n                node.key = null;\n            const cv = visit_('value', node.value, visitor, path);\n            if (cv === BREAK)\n                return BREAK;\n            else if (cv === REMOVE)\n                node.value = null;\n        }\n    }\n    return ctrl;\n}\n/**\n * Apply an async visitor to an AST node or document.\n *\n * Walks through the tree (depth-first) starting from `node`, calling a\n * `visitor` function with three arguments:\n *   - `key`: For sequence values and map `Pair`, the node's index in the\n *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.\n *     `null` for the root node.\n *   - `node`: The current node.\n *   - `path`: The ancestry of the current node.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `Promise`: Must resolve to one of the following values\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this node, continue with next\n *     sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current node, then continue with the next one\n *   - `Node`: Replace the current node, then continue by visiting it\n *   - `number`: While iterating the items of a sequence or map, set the index\n *     of the next step. This is useful especially if the index of the current\n *     node has changed.\n *\n * If `visitor` is a single function, it will be called with all values\n * encountered in the tree, including e.g. `null` values. Alternatively,\n * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,\n * `Alias` and `Scalar` node. To define the same visitor function for more than\n * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)\n * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most\n * specific defined one will be used for each node.\n */\nasync function visitAsync(node, visitor) {\n    const visitor_ = initVisitor(visitor);\n    if (isDocument(node)) {\n        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));\n        if (cd === REMOVE)\n            node.contents = null;\n    }\n    else\n        await visitAsync_(null, node, visitor_, Object.freeze([]));\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisitAsync.BREAK = BREAK;\n/** Do not visit the children of the current node */\nvisitAsync.SKIP = SKIP;\n/** Remove the current node */\nvisitAsync.REMOVE = REMOVE;\nasync function visitAsync_(key, node, visitor, path) {\n    const ctrl = await callVisitor(key, node, visitor, path);\n    if (isNode(ctrl) || isPair(ctrl)) {\n        replaceNode(key, path, ctrl);\n        return visitAsync_(key, ctrl, visitor, path);\n    }\n    if (typeof ctrl !== 'symbol') {\n        if (isCollection(node)) {\n            path = Object.freeze(path.concat(node));\n            for (let i = 0; i < node.items.length; ++i) {\n                const ci = await visitAsync_(i, node.items[i], visitor, path);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    node.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n        }\n        else if (isPair(node)) {\n            path = Object.freeze(path.concat(node));\n            const ck = await visitAsync_('key', node.key, visitor, path);\n            if (ck === BREAK)\n                return BREAK;\n            else if (ck === REMOVE)\n                node.key = null;\n            const cv = await visitAsync_('value', node.value, visitor, path);\n            if (cv === BREAK)\n                return BREAK;\n            else if (cv === REMOVE)\n                node.value = null;\n        }\n    }\n    return ctrl;\n}\nfunction initVisitor(visitor) {\n    if (typeof visitor === 'object' &&\n        (visitor.Collection || visitor.Node || visitor.Value)) {\n        return Object.assign({\n            Alias: visitor.Node,\n            Map: visitor.Node,\n            Scalar: visitor.Node,\n            Seq: visitor.Node\n        }, visitor.Value && {\n            Map: visitor.Value,\n            Scalar: visitor.Value,\n            Seq: visitor.Value\n        }, visitor.Collection && {\n            Map: visitor.Collection,\n            Seq: visitor.Collection\n        }, visitor);\n    }\n    return visitor;\n}\nfunction callVisitor(key, node, visitor, path) {\n    if (typeof visitor === 'function')\n        return visitor(key, node, path);\n    if (isMap(node))\n        return visitor.Map?.(key, node, path);\n    if (isSeq(node))\n        return visitor.Seq?.(key, node, path);\n    if (isPair(node))\n        return visitor.Pair?.(key, node, path);\n    if (isScalar(node))\n        return visitor.Scalar?.(key, node, path);\n    if (isAlias(node))\n        return visitor.Alias?.(key, node, path);\n    return undefined;\n}\nfunction replaceNode(key, path, node) {\n    const parent = path[path.length - 1];\n    if (isCollection(parent)) {\n        parent.items[key] = node;\n    }\n    else if (isPair(parent)) {\n        if (key === 'key')\n            parent.key = node;\n        else\n            parent.value = node;\n    }\n    else if (isDocument(parent)) {\n        parent.contents = node;\n    }\n    else {\n        const pt = isAlias(parent) ? 'alias' : 'scalar';\n        throw new Error(`Cannot replace node with ${pt} parent`);\n    }\n}\n\nexport { visit, visitAsync };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}