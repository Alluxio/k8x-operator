{"ast":null,"code":"import { Directives } from '../doc/directives.js';\nimport { Document } from '../doc/Document.js';\nimport { YAMLWarning, YAMLParseError } from '../errors.js';\nimport { isCollection, isPair } from '../nodes/identity.js';\nimport { composeDoc } from './compose-doc.js';\nimport { resolveEnd } from './resolve-end.js';\nfunction getErrorPos(src) {\n  if (typeof src === 'number') return [src, src + 1];\n  if (Array.isArray(src)) return src.length === 2 ? src : [src[0], src[1]];\n  const {\n    offset,\n    source\n  } = src;\n  return [offset, offset + (typeof source === 'string' ? source.length : 1)];\n}\nfunction parsePrelude(prelude) {\n  var _prelude;\n  let comment = '';\n  let atComment = false;\n  let afterEmptyLine = false;\n  for (let i = 0; i < prelude.length; ++i) {\n    const source = prelude[i];\n    switch (source[0]) {\n      case '#':\n        comment += (comment === '' ? '' : afterEmptyLine ? '\\n\\n' : '\\n') + (source.substring(1) || ' ');\n        atComment = true;\n        afterEmptyLine = false;\n        break;\n      case '%':\n        if (((_prelude = prelude[i + 1]) === null || _prelude === void 0 ? void 0 : _prelude[0]) !== '#') i += 1;\n        atComment = false;\n        break;\n      default:\n        // This may be wrong after doc-end, but in that case it doesn't matter\n        if (!atComment) afterEmptyLine = true;\n        atComment = false;\n    }\n  }\n  return {\n    comment,\n    afterEmptyLine\n  };\n}\n/**\n * Compose a stream of CST nodes into a stream of YAML Documents.\n *\n * ```ts\n * import { Composer, Parser } from 'yaml'\n *\n * const src: string = ...\n * const tokens = new Parser().parse(src)\n * const docs = new Composer().compose(tokens)\n * ```\n */\nclass Composer {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.doc = null;\n    this.atDirectives = false;\n    this.prelude = [];\n    this.errors = [];\n    this.warnings = [];\n    this.onError = (source, code, message, warning) => {\n      const pos = getErrorPos(source);\n      if (warning) this.warnings.push(new YAMLWarning(pos, code, message));else this.errors.push(new YAMLParseError(pos, code, message));\n    };\n    // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n    this.directives = new Directives({\n      version: options.version || '1.2'\n    });\n    this.options = options;\n  }\n  decorate(doc, afterDoc) {\n    const {\n      comment,\n      afterEmptyLine\n    } = parsePrelude(this.prelude);\n    //console.log({ dc: doc.comment, prelude, comment })\n    if (comment) {\n      const dc = doc.contents;\n      if (afterDoc) {\n        doc.comment = doc.comment ? \"\".concat(doc.comment, \"\\n\").concat(comment) : comment;\n      } else if (afterEmptyLine || doc.directives.docStart || !dc) {\n        doc.commentBefore = comment;\n      } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {\n        let it = dc.items[0];\n        if (isPair(it)) it = it.key;\n        const cb = it.commentBefore;\n        it.commentBefore = cb ? \"\".concat(comment, \"\\n\").concat(cb) : comment;\n      } else {\n        const cb = dc.commentBefore;\n        dc.commentBefore = cb ? \"\".concat(comment, \"\\n\").concat(cb) : comment;\n      }\n    }\n    if (afterDoc) {\n      Array.prototype.push.apply(doc.errors, this.errors);\n      Array.prototype.push.apply(doc.warnings, this.warnings);\n    } else {\n      doc.errors = this.errors;\n      doc.warnings = this.warnings;\n    }\n    this.prelude = [];\n    this.errors = [];\n    this.warnings = [];\n  }\n  /**\n   * Current stream status information.\n   *\n   * Mostly useful at the end of input for an empty stream.\n   */\n  streamInfo() {\n    return {\n      comment: parsePrelude(this.prelude).comment,\n      directives: this.directives,\n      errors: this.errors,\n      warnings: this.warnings\n    };\n  }\n  /**\n   * Compose tokens into documents.\n   *\n   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n   */\n  compose(tokens) {\n    var _this = this;\n    let forceDoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let endOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n    return function* () {\n      for (const token of tokens) yield* _this.next(token);\n      yield* _this.end(forceDoc, endOffset);\n    }();\n  }\n  /** Advance the composer by one CST token. */\n  *next(token) {\n    switch (token.type) {\n      case 'directive':\n        this.directives.add(token.source, (offset, message, warning) => {\n          const pos = getErrorPos(token);\n          pos[0] += offset;\n          this.onError(pos, 'BAD_DIRECTIVE', message, warning);\n        });\n        this.prelude.push(token.source);\n        this.atDirectives = true;\n        break;\n      case 'document':\n        {\n          const doc = composeDoc(this.options, this.directives, token, this.onError);\n          if (this.atDirectives && !doc.directives.docStart) this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');\n          this.decorate(doc, false);\n          if (this.doc) yield this.doc;\n          this.doc = doc;\n          this.atDirectives = false;\n          break;\n        }\n      case 'byte-order-mark':\n      case 'space':\n        break;\n      case 'comment':\n      case 'newline':\n        this.prelude.push(token.source);\n        break;\n      case 'error':\n        {\n          const msg = token.source ? \"\".concat(token.message, \": \").concat(JSON.stringify(token.source)) : token.message;\n          const error = new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);\n          if (this.atDirectives || !this.doc) this.errors.push(error);else this.doc.errors.push(error);\n          break;\n        }\n      case 'doc-end':\n        {\n          if (!this.doc) {\n            const msg = 'Unexpected doc-end without preceding document';\n            this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));\n            break;\n          }\n          this.doc.directives.docEnd = true;\n          const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);\n          this.decorate(this.doc, true);\n          if (end.comment) {\n            const dc = this.doc.comment;\n            this.doc.comment = dc ? \"\".concat(dc, \"\\n\").concat(end.comment) : end.comment;\n          }\n          this.doc.range[2] = end.offset;\n          break;\n        }\n      default:\n        this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', \"Unsupported token \".concat(token.type)));\n    }\n  }\n  /**\n   * Call at end of input to yield any remaining document.\n   *\n   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n   */\n  end() {\n    var _this2 = this;\n    let forceDoc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let endOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    return function* () {\n      if (_this2.doc) {\n        _this2.decorate(_this2.doc, true);\n        yield _this2.doc;\n        _this2.doc = null;\n      } else if (forceDoc) {\n        const opts = Object.assign({\n          _directives: _this2.directives\n        }, _this2.options);\n        const doc = new Document(undefined, opts);\n        if (_this2.atDirectives) _this2.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');\n        doc.range = [0, endOffset, endOffset];\n        _this2.decorate(doc, false);\n        yield doc;\n      }\n    }();\n  }\n}\nexport { Composer };","map":{"version":3,"names":["Directives","Document","YAMLWarning","YAMLParseError","isCollection","isPair","composeDoc","resolveEnd","getErrorPos","src","Array","isArray","length","offset","source","parsePrelude","prelude","_prelude","comment","atComment","afterEmptyLine","i","substring","Composer","constructor","options","arguments","undefined","doc","atDirectives","errors","warnings","onError","code","message","warning","pos","push","directives","version","decorate","afterDoc","dc","contents","concat","docStart","commentBefore","flow","items","it","key","cb","prototype","apply","streamInfo","compose","tokens","_this","forceDoc","endOffset","token","next","end","type","add","msg","JSON","stringify","error","docEnd","strict","range","_this2","opts","Object","assign","_directives"],"sources":["/Users/shoukaiwen/WebstormProjects/alluxio-k8s-operator-ui/node_modules/yaml/browser/dist/compose/composer.js"],"sourcesContent":["import { Directives } from '../doc/directives.js';\nimport { Document } from '../doc/Document.js';\nimport { YAMLWarning, YAMLParseError } from '../errors.js';\nimport { isCollection, isPair } from '../nodes/identity.js';\nimport { composeDoc } from './compose-doc.js';\nimport { resolveEnd } from './resolve-end.js';\n\nfunction getErrorPos(src) {\n    if (typeof src === 'number')\n        return [src, src + 1];\n    if (Array.isArray(src))\n        return src.length === 2 ? src : [src[0], src[1]];\n    const { offset, source } = src;\n    return [offset, offset + (typeof source === 'string' ? source.length : 1)];\n}\nfunction parsePrelude(prelude) {\n    let comment = '';\n    let atComment = false;\n    let afterEmptyLine = false;\n    for (let i = 0; i < prelude.length; ++i) {\n        const source = prelude[i];\n        switch (source[0]) {\n            case '#':\n                comment +=\n                    (comment === '' ? '' : afterEmptyLine ? '\\n\\n' : '\\n') +\n                        (source.substring(1) || ' ');\n                atComment = true;\n                afterEmptyLine = false;\n                break;\n            case '%':\n                if (prelude[i + 1]?.[0] !== '#')\n                    i += 1;\n                atComment = false;\n                break;\n            default:\n                // This may be wrong after doc-end, but in that case it doesn't matter\n                if (!atComment)\n                    afterEmptyLine = true;\n                atComment = false;\n        }\n    }\n    return { comment, afterEmptyLine };\n}\n/**\n * Compose a stream of CST nodes into a stream of YAML Documents.\n *\n * ```ts\n * import { Composer, Parser } from 'yaml'\n *\n * const src: string = ...\n * const tokens = new Parser().parse(src)\n * const docs = new Composer().compose(tokens)\n * ```\n */\nclass Composer {\n    constructor(options = {}) {\n        this.doc = null;\n        this.atDirectives = false;\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n        this.onError = (source, code, message, warning) => {\n            const pos = getErrorPos(source);\n            if (warning)\n                this.warnings.push(new YAMLWarning(pos, code, message));\n            else\n                this.errors.push(new YAMLParseError(pos, code, message));\n        };\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        this.directives = new Directives({ version: options.version || '1.2' });\n        this.options = options;\n    }\n    decorate(doc, afterDoc) {\n        const { comment, afterEmptyLine } = parsePrelude(this.prelude);\n        //console.log({ dc: doc.comment, prelude, comment })\n        if (comment) {\n            const dc = doc.contents;\n            if (afterDoc) {\n                doc.comment = doc.comment ? `${doc.comment}\\n${comment}` : comment;\n            }\n            else if (afterEmptyLine || doc.directives.docStart || !dc) {\n                doc.commentBefore = comment;\n            }\n            else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {\n                let it = dc.items[0];\n                if (isPair(it))\n                    it = it.key;\n                const cb = it.commentBefore;\n                it.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n            else {\n                const cb = dc.commentBefore;\n                dc.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n        }\n        if (afterDoc) {\n            Array.prototype.push.apply(doc.errors, this.errors);\n            Array.prototype.push.apply(doc.warnings, this.warnings);\n        }\n        else {\n            doc.errors = this.errors;\n            doc.warnings = this.warnings;\n        }\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n    }\n    /**\n     * Current stream status information.\n     *\n     * Mostly useful at the end of input for an empty stream.\n     */\n    streamInfo() {\n        return {\n            comment: parsePrelude(this.prelude).comment,\n            directives: this.directives,\n            errors: this.errors,\n            warnings: this.warnings\n        };\n    }\n    /**\n     * Compose tokens into documents.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *compose(tokens, forceDoc = false, endOffset = -1) {\n        for (const token of tokens)\n            yield* this.next(token);\n        yield* this.end(forceDoc, endOffset);\n    }\n    /** Advance the composer by one CST token. */\n    *next(token) {\n        switch (token.type) {\n            case 'directive':\n                this.directives.add(token.source, (offset, message, warning) => {\n                    const pos = getErrorPos(token);\n                    pos[0] += offset;\n                    this.onError(pos, 'BAD_DIRECTIVE', message, warning);\n                });\n                this.prelude.push(token.source);\n                this.atDirectives = true;\n                break;\n            case 'document': {\n                const doc = composeDoc(this.options, this.directives, token, this.onError);\n                if (this.atDirectives && !doc.directives.docStart)\n                    this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');\n                this.decorate(doc, false);\n                if (this.doc)\n                    yield this.doc;\n                this.doc = doc;\n                this.atDirectives = false;\n                break;\n            }\n            case 'byte-order-mark':\n            case 'space':\n                break;\n            case 'comment':\n            case 'newline':\n                this.prelude.push(token.source);\n                break;\n            case 'error': {\n                const msg = token.source\n                    ? `${token.message}: ${JSON.stringify(token.source)}`\n                    : token.message;\n                const error = new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);\n                if (this.atDirectives || !this.doc)\n                    this.errors.push(error);\n                else\n                    this.doc.errors.push(error);\n                break;\n            }\n            case 'doc-end': {\n                if (!this.doc) {\n                    const msg = 'Unexpected doc-end without preceding document';\n                    this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));\n                    break;\n                }\n                this.doc.directives.docEnd = true;\n                const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);\n                this.decorate(this.doc, true);\n                if (end.comment) {\n                    const dc = this.doc.comment;\n                    this.doc.comment = dc ? `${dc}\\n${end.comment}` : end.comment;\n                }\n                this.doc.range[2] = end.offset;\n                break;\n            }\n            default:\n                this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));\n        }\n    }\n    /**\n     * Call at end of input to yield any remaining document.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *end(forceDoc = false, endOffset = -1) {\n        if (this.doc) {\n            this.decorate(this.doc, true);\n            yield this.doc;\n            this.doc = null;\n        }\n        else if (forceDoc) {\n            const opts = Object.assign({ _directives: this.directives }, this.options);\n            const doc = new Document(undefined, opts);\n            if (this.atDirectives)\n                this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');\n            doc.range = [0, endOffset, endOffset];\n            this.decorate(doc, false);\n            yield doc;\n        }\n    }\n}\n\nexport { Composer };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}