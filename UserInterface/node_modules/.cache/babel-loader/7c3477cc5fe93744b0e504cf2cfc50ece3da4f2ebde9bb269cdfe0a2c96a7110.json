{"ast":null,"code":"import { isNode } from '../nodes/identity.js';\nimport { Scalar } from '../nodes/Scalar.js';\nimport { YAMLMap } from '../nodes/YAMLMap.js';\nimport { YAMLSeq } from '../nodes/YAMLSeq.js';\nimport { resolveBlockMap } from './resolve-block-map.js';\nimport { resolveBlockSeq } from './resolve-block-seq.js';\nimport { resolveFlowCollection } from './resolve-flow-collection.js';\nfunction resolveCollection(CN, ctx, token, onError, tagName, tag) {\n  const coll = token.type === 'block-map' ? resolveBlockMap(CN, ctx, token, onError, tag) : token.type === 'block-seq' ? resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection(CN, ctx, token, onError, tag);\n  const Coll = coll.constructor;\n  // If we got a tagName matching the class, or the tag name is '!',\n  // then use the tagName from the node class used to create it.\n  if (tagName === '!' || tagName === Coll.tagName) {\n    coll.tag = Coll.tagName;\n    return coll;\n  }\n  if (tagName) coll.tag = tagName;\n  return coll;\n}\nfunction composeCollection(CN, ctx, token, tagToken, onError) {\n  var _tag$resolve, _tag$resolve2, _tag, _tag2;\n  const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));\n  const expType = token.type === 'block-map' ? 'map' : token.type === 'block-seq' ? 'seq' : token.start.source === '{' ? 'map' : 'seq';\n  // shortcut: check if it's a generic YAMLMap or YAMLSeq\n  // before jumping into the custom tag logic.\n  if (!tagToken || !tagName || tagName === '!' || tagName === YAMLMap.tagName && expType === 'map' || tagName === YAMLSeq.tagName && expType === 'seq' || !expType) {\n    return resolveCollection(CN, ctx, token, onError, tagName);\n  }\n  let tag = ctx.schema.tags.find(t => t.tag === tagName && t.collection === expType);\n  if (!tag) {\n    const kt = ctx.schema.knownTags[tagName];\n    if (kt && kt.collection === expType) {\n      ctx.schema.tags.push(Object.assign({}, kt, {\n        default: false\n      }));\n      tag = kt;\n    } else {\n      if (kt !== null && kt !== void 0 && kt.collection) {\n        onError(tagToken, 'BAD_COLLECTION_TYPE', \"\".concat(kt.tag, \" used for \").concat(expType, \" collection, but expects \").concat(kt.collection), true);\n      } else {\n        onError(tagToken, 'TAG_RESOLVE_FAILED', \"Unresolved tag: \".concat(tagName), true);\n      }\n      return resolveCollection(CN, ctx, token, onError, tagName);\n    }\n  }\n  const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);\n  const res = (_tag$resolve = (_tag$resolve2 = (_tag = tag).resolve) === null || _tag$resolve2 === void 0 ? void 0 : _tag$resolve2.call(_tag, coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options)) !== null && _tag$resolve !== void 0 ? _tag$resolve : coll;\n  const node = isNode(res) ? res : new Scalar(res);\n  node.range = coll.range;\n  node.tag = tagName;\n  if ((_tag2 = tag) !== null && _tag2 !== void 0 && _tag2.format) node.format = tag.format;\n  return node;\n}\nexport { composeCollection };","map":{"version":3,"names":["isNode","Scalar","YAMLMap","YAMLSeq","resolveBlockMap","resolveBlockSeq","resolveFlowCollection","resolveCollection","CN","ctx","token","onError","tagName","tag","coll","type","Coll","constructor","composeCollection","tagToken","_tag$resolve","_tag$resolve2","_tag","_tag2","directives","source","msg","expType","start","schema","tags","find","t","collection","kt","knownTags","push","Object","assign","default","concat","res","resolve","call","options","node","range","format"],"sources":["/Users/shoukaiwen/WebstormProjects/alluxio-k8s-operator-ui/node_modules/yaml/browser/dist/compose/compose-collection.js"],"sourcesContent":["import { isNode } from '../nodes/identity.js';\nimport { Scalar } from '../nodes/Scalar.js';\nimport { YAMLMap } from '../nodes/YAMLMap.js';\nimport { YAMLSeq } from '../nodes/YAMLSeq.js';\nimport { resolveBlockMap } from './resolve-block-map.js';\nimport { resolveBlockSeq } from './resolve-block-seq.js';\nimport { resolveFlowCollection } from './resolve-flow-collection.js';\n\nfunction resolveCollection(CN, ctx, token, onError, tagName, tag) {\n    const coll = token.type === 'block-map'\n        ? resolveBlockMap(CN, ctx, token, onError, tag)\n        : token.type === 'block-seq'\n            ? resolveBlockSeq(CN, ctx, token, onError, tag)\n            : resolveFlowCollection(CN, ctx, token, onError, tag);\n    const Coll = coll.constructor;\n    // If we got a tagName matching the class, or the tag name is '!',\n    // then use the tagName from the node class used to create it.\n    if (tagName === '!' || tagName === Coll.tagName) {\n        coll.tag = Coll.tagName;\n        return coll;\n    }\n    if (tagName)\n        coll.tag = tagName;\n    return coll;\n}\nfunction composeCollection(CN, ctx, token, tagToken, onError) {\n    const tagName = !tagToken\n        ? null\n        : ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));\n    const expType = token.type === 'block-map'\n        ? 'map'\n        : token.type === 'block-seq'\n            ? 'seq'\n            : token.start.source === '{'\n                ? 'map'\n                : 'seq';\n    // shortcut: check if it's a generic YAMLMap or YAMLSeq\n    // before jumping into the custom tag logic.\n    if (!tagToken ||\n        !tagName ||\n        tagName === '!' ||\n        (tagName === YAMLMap.tagName && expType === 'map') ||\n        (tagName === YAMLSeq.tagName && expType === 'seq') ||\n        !expType) {\n        return resolveCollection(CN, ctx, token, onError, tagName);\n    }\n    let tag = ctx.schema.tags.find(t => t.tag === tagName && t.collection === expType);\n    if (!tag) {\n        const kt = ctx.schema.knownTags[tagName];\n        if (kt && kt.collection === expType) {\n            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));\n            tag = kt;\n        }\n        else {\n            if (kt?.collection) {\n                onError(tagToken, 'BAD_COLLECTION_TYPE', `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);\n            }\n            else {\n                onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);\n            }\n            return resolveCollection(CN, ctx, token, onError, tagName);\n        }\n    }\n    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);\n    const res = tag.resolve?.(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options) ?? coll;\n    const node = isNode(res)\n        ? res\n        : new Scalar(res);\n    node.range = coll.range;\n    node.tag = tagName;\n    if (tag?.format)\n        node.format = tag.format;\n    return node;\n}\n\nexport { composeCollection };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}