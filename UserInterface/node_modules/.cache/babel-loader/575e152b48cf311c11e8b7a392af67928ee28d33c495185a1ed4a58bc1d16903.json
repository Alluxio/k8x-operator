{"ast":null,"code":"const FOLD_FLOW = 'flow';\nconst FOLD_BLOCK = 'block';\nconst FOLD_QUOTED = 'quoted';\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n */\nfunction foldFlowLines(text, indent) {\n  let mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'flow';\n  let {\n    indentAtStart,\n    lineWidth = 80,\n    minContentWidth = 20,\n    onFold,\n    onOverflow\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  if (!lineWidth || lineWidth < 0) return text;\n  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n  if (text.length <= endStep) return text;\n  const folds = [];\n  const escapedFolds = {};\n  let end = lineWidth - indent.length;\n  if (typeof indentAtStart === 'number') {\n    if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);else end = lineWidth - indentAtStart;\n  }\n  let split = undefined;\n  let prev = undefined;\n  let overflow = false;\n  let i = -1;\n  let escStart = -1;\n  let escEnd = -1;\n  if (mode === FOLD_BLOCK) {\n    i = consumeMoreIndentedLines(text, i);\n    if (i !== -1) end = i + endStep;\n  }\n  for (let ch; ch = text[i += 1];) {\n    if (mode === FOLD_QUOTED && ch === '\\\\') {\n      escStart = i;\n      switch (text[i + 1]) {\n        case 'x':\n          i += 3;\n          break;\n        case 'u':\n          i += 5;\n          break;\n        case 'U':\n          i += 9;\n          break;\n        default:\n          i += 1;\n      }\n      escEnd = i;\n    }\n    if (ch === '\\n') {\n      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);\n      end = i + endStep;\n      split = undefined;\n    } else {\n      if (ch === ' ' && prev && prev !== ' ' && prev !== '\\n' && prev !== '\\t') {\n        // space surrounded by non-space can be replaced with newline + indent\n        const next = text[i + 1];\n        if (next && next !== ' ' && next !== '\\n' && next !== '\\t') split = i;\n      }\n      if (i >= end) {\n        if (split) {\n          folds.push(split);\n          end = split + endStep;\n          split = undefined;\n        } else if (mode === FOLD_QUOTED) {\n          // white-space collected at end may stretch past lineWidth\n          while (prev === ' ' || prev === '\\t') {\n            prev = ch;\n            ch = text[i += 1];\n            overflow = true;\n          }\n          // Account for newline escape, but don't break preceding escape\n          const j = i > escEnd + 1 ? i - 2 : escStart - 1;\n          // Bail out if lineWidth & minContentWidth are shorter than an escape string\n          if (escapedFolds[j]) return text;\n          folds.push(j);\n          escapedFolds[j] = true;\n          end = j + endStep;\n          split = undefined;\n        } else {\n          overflow = true;\n        }\n      }\n    }\n    prev = ch;\n  }\n  if (overflow && onOverflow) onOverflow();\n  if (folds.length === 0) return text;\n  if (onFold) onFold();\n  let res = text.slice(0, folds[0]);\n  for (let i = 0; i < folds.length; ++i) {\n    const fold = folds[i];\n    const end = folds[i + 1] || text.length;\n    if (fold === 0) res = \"\\n\".concat(indent).concat(text.slice(0, end));else {\n      if (mode === FOLD_QUOTED && escapedFolds[fold]) res += \"\".concat(text[fold], \"\\\\\");\n      res += \"\\n\".concat(indent).concat(text.slice(fold + 1, end));\n    }\n  }\n  return res;\n}\n/**\n * Presumes `i + 1` is at the start of a line\n * @returns index of last newline in more-indented block\n */\nfunction consumeMoreIndentedLines(text, i) {\n  let ch = text[i + 1];\n  while (ch === ' ' || ch === '\\t') {\n    do {\n      ch = text[i += 1];\n    } while (ch && ch !== '\\n');\n    ch = text[i + 1];\n  }\n  return i;\n}\nexport { FOLD_BLOCK, FOLD_FLOW, FOLD_QUOTED, foldFlowLines };","map":{"version":3,"names":["FOLD_FLOW","FOLD_BLOCK","FOLD_QUOTED","foldFlowLines","text","indent","mode","arguments","length","undefined","indentAtStart","lineWidth","minContentWidth","onFold","onOverflow","endStep","Math","max","folds","escapedFolds","end","push","split","prev","overflow","i","escStart","escEnd","consumeMoreIndentedLines","ch","next","j","res","slice","fold","concat"],"sources":["/Users/shoukaiwen/WebstormProjects/alluxio-k8s-operator-ui/node_modules/yaml/browser/dist/stringify/foldFlowLines.js"],"sourcesContent":["const FOLD_FLOW = 'flow';\nconst FOLD_BLOCK = 'block';\nconst FOLD_QUOTED = 'quoted';\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n */\nfunction foldFlowLines(text, indent, mode = 'flow', { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {\n    if (!lineWidth || lineWidth < 0)\n        return text;\n    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n    if (text.length <= endStep)\n        return text;\n    const folds = [];\n    const escapedFolds = {};\n    let end = lineWidth - indent.length;\n    if (typeof indentAtStart === 'number') {\n        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))\n            folds.push(0);\n        else\n            end = lineWidth - indentAtStart;\n    }\n    let split = undefined;\n    let prev = undefined;\n    let overflow = false;\n    let i = -1;\n    let escStart = -1;\n    let escEnd = -1;\n    if (mode === FOLD_BLOCK) {\n        i = consumeMoreIndentedLines(text, i);\n        if (i !== -1)\n            end = i + endStep;\n    }\n    for (let ch; (ch = text[(i += 1)]);) {\n        if (mode === FOLD_QUOTED && ch === '\\\\') {\n            escStart = i;\n            switch (text[i + 1]) {\n                case 'x':\n                    i += 3;\n                    break;\n                case 'u':\n                    i += 5;\n                    break;\n                case 'U':\n                    i += 9;\n                    break;\n                default:\n                    i += 1;\n            }\n            escEnd = i;\n        }\n        if (ch === '\\n') {\n            if (mode === FOLD_BLOCK)\n                i = consumeMoreIndentedLines(text, i);\n            end = i + endStep;\n            split = undefined;\n        }\n        else {\n            if (ch === ' ' &&\n                prev &&\n                prev !== ' ' &&\n                prev !== '\\n' &&\n                prev !== '\\t') {\n                // space surrounded by non-space can be replaced with newline + indent\n                const next = text[i + 1];\n                if (next && next !== ' ' && next !== '\\n' && next !== '\\t')\n                    split = i;\n            }\n            if (i >= end) {\n                if (split) {\n                    folds.push(split);\n                    end = split + endStep;\n                    split = undefined;\n                }\n                else if (mode === FOLD_QUOTED) {\n                    // white-space collected at end may stretch past lineWidth\n                    while (prev === ' ' || prev === '\\t') {\n                        prev = ch;\n                        ch = text[(i += 1)];\n                        overflow = true;\n                    }\n                    // Account for newline escape, but don't break preceding escape\n                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;\n                    // Bail out if lineWidth & minContentWidth are shorter than an escape string\n                    if (escapedFolds[j])\n                        return text;\n                    folds.push(j);\n                    escapedFolds[j] = true;\n                    end = j + endStep;\n                    split = undefined;\n                }\n                else {\n                    overflow = true;\n                }\n            }\n        }\n        prev = ch;\n    }\n    if (overflow && onOverflow)\n        onOverflow();\n    if (folds.length === 0)\n        return text;\n    if (onFold)\n        onFold();\n    let res = text.slice(0, folds[0]);\n    for (let i = 0; i < folds.length; ++i) {\n        const fold = folds[i];\n        const end = folds[i + 1] || text.length;\n        if (fold === 0)\n            res = `\\n${indent}${text.slice(0, end)}`;\n        else {\n            if (mode === FOLD_QUOTED && escapedFolds[fold])\n                res += `${text[fold]}\\\\`;\n            res += `\\n${indent}${text.slice(fold + 1, end)}`;\n        }\n    }\n    return res;\n}\n/**\n * Presumes `i + 1` is at the start of a line\n * @returns index of last newline in more-indented block\n */\nfunction consumeMoreIndentedLines(text, i) {\n    let ch = text[i + 1];\n    while (ch === ' ' || ch === '\\t') {\n        do {\n            ch = text[(i += 1)];\n        } while (ch && ch !== '\\n');\n        ch = text[i + 1];\n    }\n    return i;\n}\n\nexport { FOLD_BLOCK, FOLD_FLOW, FOLD_QUOTED, foldFlowLines };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}