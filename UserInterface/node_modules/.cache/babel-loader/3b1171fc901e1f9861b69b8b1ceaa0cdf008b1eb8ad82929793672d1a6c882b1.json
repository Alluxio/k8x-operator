{"ast":null,"code":"import { Composer } from './compose/composer.js';\nimport { Document } from './doc/Document.js';\nimport { prettifyError, YAMLParseError } from './errors.js';\nimport { warn } from './log.js';\nimport { LineCounter } from './parse/line-counter.js';\nimport { Parser } from './parse/parser.js';\nfunction parseOptions(options) {\n  const prettyErrors = options.prettyErrors !== false;\n  const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;\n  return {\n    lineCounter,\n    prettyErrors\n  };\n}\n/**\n * Parse the input as a stream of YAML documents.\n *\n * Documents should be separated from each other by `...` or `---` marker lines.\n *\n * @returns If an empty `docs` array is returned, it will be of type\n *   EmptyStream and contain additional stream information. In\n *   TypeScript, you should use `'empty' in docs` as a type guard for it.\n */\nfunction parseAllDocuments(source) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    lineCounter,\n    prettyErrors\n  } = parseOptions(options);\n  const parser = new Parser(lineCounter === null || lineCounter === void 0 ? void 0 : lineCounter.addNewLine);\n  const composer = new Composer(options);\n  const docs = Array.from(composer.compose(parser.parse(source)));\n  if (prettyErrors && lineCounter) for (const doc of docs) {\n    doc.errors.forEach(prettifyError(source, lineCounter));\n    doc.warnings.forEach(prettifyError(source, lineCounter));\n  }\n  if (docs.length > 0) return docs;\n  return Object.assign([], {\n    empty: true\n  }, composer.streamInfo());\n}\n/** Parse an input string into a single YAML.Document */\nfunction parseDocument(source) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    lineCounter,\n    prettyErrors\n  } = parseOptions(options);\n  const parser = new Parser(lineCounter === null || lineCounter === void 0 ? void 0 : lineCounter.addNewLine);\n  const composer = new Composer(options);\n  // `doc` is always set by compose.end(true) at the very latest\n  let doc = null;\n  for (const _doc of composer.compose(parser.parse(source), true, source.length)) {\n    if (!doc) doc = _doc;else if (doc.options.logLevel !== 'silent') {\n      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));\n      break;\n    }\n  }\n  if (prettyErrors && lineCounter) {\n    doc.errors.forEach(prettifyError(source, lineCounter));\n    doc.warnings.forEach(prettifyError(source, lineCounter));\n  }\n  return doc;\n}\nfunction parse(src, reviver, options) {\n  let _reviver = undefined;\n  if (typeof reviver === 'function') {\n    _reviver = reviver;\n  } else if (options === undefined && reviver && typeof reviver === 'object') {\n    options = reviver;\n  }\n  const doc = parseDocument(src, options);\n  if (!doc) return null;\n  doc.warnings.forEach(warning => warn(doc.options.logLevel, warning));\n  if (doc.errors.length > 0) {\n    if (doc.options.logLevel !== 'silent') throw doc.errors[0];else doc.errors = [];\n  }\n  return doc.toJS(Object.assign({\n    reviver: _reviver\n  }, options));\n}\nfunction stringify(value, replacer, options) {\n  let _replacer = null;\n  if (typeof replacer === 'function' || Array.isArray(replacer)) {\n    _replacer = replacer;\n  } else if (options === undefined && replacer) {\n    options = replacer;\n  }\n  if (typeof options === 'string') options = options.length;\n  if (typeof options === 'number') {\n    const indent = Math.round(options);\n    options = indent < 1 ? undefined : indent > 8 ? {\n      indent: 8\n    } : {\n      indent\n    };\n  }\n  if (value === undefined) {\n    var _ref, _options;\n    const {\n      keepUndefined\n    } = (_ref = (_options = options) !== null && _options !== void 0 ? _options : replacer) !== null && _ref !== void 0 ? _ref : {};\n    if (!keepUndefined) return undefined;\n  }\n  return new Document(value, _replacer, options).toString(options);\n}\nexport { parse, parseAllDocuments, parseDocument, stringify };","map":{"version":3,"names":["Composer","Document","prettifyError","YAMLParseError","warn","LineCounter","Parser","parseOptions","options","prettyErrors","lineCounter","parseAllDocuments","source","arguments","length","undefined","parser","addNewLine","composer","docs","Array","from","compose","parse","doc","errors","forEach","warnings","Object","assign","empty","streamInfo","parseDocument","_doc","logLevel","push","range","slice","src","reviver","_reviver","warning","toJS","stringify","value","replacer","_replacer","isArray","indent","Math","round","_ref","_options","keepUndefined","toString"],"sources":["/Users/shoukaiwen/WebstormProjects/alluxio-k8s-operator-ui/node_modules/yaml/browser/dist/public-api.js"],"sourcesContent":["import { Composer } from './compose/composer.js';\nimport { Document } from './doc/Document.js';\nimport { prettifyError, YAMLParseError } from './errors.js';\nimport { warn } from './log.js';\nimport { LineCounter } from './parse/line-counter.js';\nimport { Parser } from './parse/parser.js';\n\nfunction parseOptions(options) {\n    const prettyErrors = options.prettyErrors !== false;\n    const lineCounter = options.lineCounter || (prettyErrors && new LineCounter()) || null;\n    return { lineCounter, prettyErrors };\n}\n/**\n * Parse the input as a stream of YAML documents.\n *\n * Documents should be separated from each other by `...` or `---` marker lines.\n *\n * @returns If an empty `docs` array is returned, it will be of type\n *   EmptyStream and contain additional stream information. In\n *   TypeScript, you should use `'empty' in docs` as a type guard for it.\n */\nfunction parseAllDocuments(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser = new Parser(lineCounter?.addNewLine);\n    const composer = new Composer(options);\n    const docs = Array.from(composer.compose(parser.parse(source)));\n    if (prettyErrors && lineCounter)\n        for (const doc of docs) {\n            doc.errors.forEach(prettifyError(source, lineCounter));\n            doc.warnings.forEach(prettifyError(source, lineCounter));\n        }\n    if (docs.length > 0)\n        return docs;\n    return Object.assign([], { empty: true }, composer.streamInfo());\n}\n/** Parse an input string into a single YAML.Document */\nfunction parseDocument(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser = new Parser(lineCounter?.addNewLine);\n    const composer = new Composer(options);\n    // `doc` is always set by compose.end(true) at the very latest\n    let doc = null;\n    for (const _doc of composer.compose(parser.parse(source), true, source.length)) {\n        if (!doc)\n            doc = _doc;\n        else if (doc.options.logLevel !== 'silent') {\n            doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));\n            break;\n        }\n    }\n    if (prettyErrors && lineCounter) {\n        doc.errors.forEach(prettifyError(source, lineCounter));\n        doc.warnings.forEach(prettifyError(source, lineCounter));\n    }\n    return doc;\n}\nfunction parse(src, reviver, options) {\n    let _reviver = undefined;\n    if (typeof reviver === 'function') {\n        _reviver = reviver;\n    }\n    else if (options === undefined && reviver && typeof reviver === 'object') {\n        options = reviver;\n    }\n    const doc = parseDocument(src, options);\n    if (!doc)\n        return null;\n    doc.warnings.forEach(warning => warn(doc.options.logLevel, warning));\n    if (doc.errors.length > 0) {\n        if (doc.options.logLevel !== 'silent')\n            throw doc.errors[0];\n        else\n            doc.errors = [];\n    }\n    return doc.toJS(Object.assign({ reviver: _reviver }, options));\n}\nfunction stringify(value, replacer, options) {\n    let _replacer = null;\n    if (typeof replacer === 'function' || Array.isArray(replacer)) {\n        _replacer = replacer;\n    }\n    else if (options === undefined && replacer) {\n        options = replacer;\n    }\n    if (typeof options === 'string')\n        options = options.length;\n    if (typeof options === 'number') {\n        const indent = Math.round(options);\n        options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };\n    }\n    if (value === undefined) {\n        const { keepUndefined } = options ?? replacer ?? {};\n        if (!keepUndefined)\n            return undefined;\n    }\n    return new Document(value, _replacer, options).toString(options);\n}\n\nexport { parse, parseAllDocuments, parseDocument, stringify };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}