{"ast":null,"code":"import { isCollection, isNode, isScalar, isSeq } from '../nodes/identity.js';\nimport { Scalar } from '../nodes/Scalar.js';\nimport { stringify } from './stringify.js';\nimport { lineComment, indentComment } from './stringifyComment.js';\nfunction stringifyPair(_ref, ctx, onComment, onChompKeep) {\n  let {\n    key,\n    value\n  } = _ref;\n  const {\n    allNullValues,\n    doc,\n    indent,\n    indentStep,\n    options: {\n      commentString,\n      indentSeq,\n      simpleKeys\n    }\n  } = ctx;\n  let keyComment = isNode(key) && key.comment || null;\n  if (simpleKeys) {\n    if (keyComment) {\n      throw new Error('With simple keys, key nodes cannot have comments');\n    }\n    if (isCollection(key)) {\n      const msg = 'With simple keys, collection cannot be used as a key value';\n      throw new Error(msg);\n    }\n  }\n  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === 'object'));\n  ctx = Object.assign({}, ctx, {\n    allNullValues: false,\n    implicitKey: !explicitKey && (simpleKeys || !allNullValues),\n    indent: indent + indentStep\n  });\n  let keyCommentDone = false;\n  let chompKeep = false;\n  let str = stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);\n  if (!explicitKey && !ctx.inFlow && str.length > 1024) {\n    if (simpleKeys) throw new Error('With simple keys, single line scalar must not span more than 1024 characters');\n    explicitKey = true;\n  }\n  if (ctx.inFlow) {\n    if (allNullValues || value == null) {\n      if (keyCommentDone && onComment) onComment();\n      return str === '' ? '?' : explicitKey ? \"? \".concat(str) : str;\n    }\n  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {\n    str = \"? \".concat(str);\n    if (keyComment && !keyCommentDone) {\n      str += lineComment(str, ctx.indent, commentString(keyComment));\n    } else if (chompKeep && onChompKeep) onChompKeep();\n    return str;\n  }\n  if (keyCommentDone) keyComment = null;\n  if (explicitKey) {\n    if (keyComment) str += lineComment(str, ctx.indent, commentString(keyComment));\n    str = \"? \".concat(str, \"\\n\").concat(indent, \":\");\n  } else {\n    str = \"\".concat(str, \":\");\n    if (keyComment) str += lineComment(str, ctx.indent, commentString(keyComment));\n  }\n  let vsb, vcb, valueComment;\n  if (isNode(value)) {\n    vsb = !!value.spaceBefore;\n    vcb = value.commentBefore;\n    valueComment = value.comment;\n  } else {\n    vsb = false;\n    vcb = null;\n    valueComment = null;\n    if (value && typeof value === 'object') value = doc.createNode(value);\n  }\n  ctx.implicitKey = false;\n  if (!explicitKey && !keyComment && isScalar(value)) ctx.indentAtStart = str.length + 1;\n  chompKeep = false;\n  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {\n    // If indentSeq === false, consider '- ' as part of indentation where possible\n    ctx.indent = ctx.indent.substring(2);\n  }\n  let valueCommentDone = false;\n  const valueStr = stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);\n  let ws = ' ';\n  if (keyComment || vsb || vcb) {\n    ws = vsb ? '\\n' : '';\n    if (vcb) {\n      const cs = commentString(vcb);\n      ws += \"\\n\".concat(indentComment(cs, ctx.indent));\n    }\n    if (valueStr === '' && !ctx.inFlow) {\n      if (ws === '\\n') ws = '\\n\\n';\n    } else {\n      ws += \"\\n\".concat(ctx.indent);\n    }\n  } else if (!explicitKey && isCollection(value)) {\n    var _ref2, _ctx$inFlow;\n    const vs0 = valueStr[0];\n    const nl0 = valueStr.indexOf('\\n');\n    const hasNewline = nl0 !== -1;\n    const flow = (_ref2 = (_ctx$inFlow = ctx.inFlow) !== null && _ctx$inFlow !== void 0 ? _ctx$inFlow : value.flow) !== null && _ref2 !== void 0 ? _ref2 : value.items.length === 0;\n    if (hasNewline || !flow) {\n      let hasPropsLine = false;\n      if (hasNewline && (vs0 === '&' || vs0 === '!')) {\n        let sp0 = valueStr.indexOf(' ');\n        if (vs0 === '&' && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === '!') {\n          sp0 = valueStr.indexOf(' ', sp0 + 1);\n        }\n        if (sp0 === -1 || nl0 < sp0) hasPropsLine = true;\n      }\n      if (!hasPropsLine) ws = \"\\n\".concat(ctx.indent);\n    }\n  } else if (valueStr === '' || valueStr[0] === '\\n') {\n    ws = '';\n  }\n  str += ws + valueStr;\n  if (ctx.inFlow) {\n    if (valueCommentDone && onComment) onComment();\n  } else if (valueComment && !valueCommentDone) {\n    str += lineComment(str, ctx.indent, commentString(valueComment));\n  } else if (chompKeep && onChompKeep) {\n    onChompKeep();\n  }\n  return str;\n}\nexport { stringifyPair };","map":{"version":3,"names":["isCollection","isNode","isScalar","isSeq","Scalar","stringify","lineComment","indentComment","stringifyPair","_ref","ctx","onComment","onChompKeep","key","value","allNullValues","doc","indent","indentStep","options","commentString","indentSeq","simpleKeys","keyComment","comment","Error","msg","explicitKey","inFlow","type","BLOCK_FOLDED","BLOCK_LITERAL","Object","assign","implicitKey","keyCommentDone","chompKeep","str","length","concat","vsb","vcb","valueComment","spaceBefore","commentBefore","createNode","indentAtStart","flow","tag","anchor","substring","valueCommentDone","valueStr","ws","cs","_ref2","_ctx$inFlow","vs0","nl0","indexOf","hasNewline","items","hasPropsLine","sp0"],"sources":["/Users/shoukaiwen/WebstormProjects/alluxio-k8s-operator-ui/node_modules/yaml/browser/dist/stringify/stringifyPair.js"],"sourcesContent":["import { isCollection, isNode, isScalar, isSeq } from '../nodes/identity.js';\nimport { Scalar } from '../nodes/Scalar.js';\nimport { stringify } from './stringify.js';\nimport { lineComment, indentComment } from './stringifyComment.js';\n\nfunction stringifyPair({ key, value }, ctx, onComment, onChompKeep) {\n    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;\n    let keyComment = (isNode(key) && key.comment) || null;\n    if (simpleKeys) {\n        if (keyComment) {\n            throw new Error('With simple keys, key nodes cannot have comments');\n        }\n        if (isCollection(key)) {\n            const msg = 'With simple keys, collection cannot be used as a key value';\n            throw new Error(msg);\n        }\n    }\n    let explicitKey = !simpleKeys &&\n        (!key ||\n            (keyComment && value == null && !ctx.inFlow) ||\n            isCollection(key) ||\n            (isScalar(key)\n                ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL\n                : typeof key === 'object'));\n    ctx = Object.assign({}, ctx, {\n        allNullValues: false,\n        implicitKey: !explicitKey && (simpleKeys || !allNullValues),\n        indent: indent + indentStep\n    });\n    let keyCommentDone = false;\n    let chompKeep = false;\n    let str = stringify(key, ctx, () => (keyCommentDone = true), () => (chompKeep = true));\n    if (!explicitKey && !ctx.inFlow && str.length > 1024) {\n        if (simpleKeys)\n            throw new Error('With simple keys, single line scalar must not span more than 1024 characters');\n        explicitKey = true;\n    }\n    if (ctx.inFlow) {\n        if (allNullValues || value == null) {\n            if (keyCommentDone && onComment)\n                onComment();\n            return str === '' ? '?' : explicitKey ? `? ${str}` : str;\n        }\n    }\n    else if ((allNullValues && !simpleKeys) || (value == null && explicitKey)) {\n        str = `? ${str}`;\n        if (keyComment && !keyCommentDone) {\n            str += lineComment(str, ctx.indent, commentString(keyComment));\n        }\n        else if (chompKeep && onChompKeep)\n            onChompKeep();\n        return str;\n    }\n    if (keyCommentDone)\n        keyComment = null;\n    if (explicitKey) {\n        if (keyComment)\n            str += lineComment(str, ctx.indent, commentString(keyComment));\n        str = `? ${str}\\n${indent}:`;\n    }\n    else {\n        str = `${str}:`;\n        if (keyComment)\n            str += lineComment(str, ctx.indent, commentString(keyComment));\n    }\n    let vsb, vcb, valueComment;\n    if (isNode(value)) {\n        vsb = !!value.spaceBefore;\n        vcb = value.commentBefore;\n        valueComment = value.comment;\n    }\n    else {\n        vsb = false;\n        vcb = null;\n        valueComment = null;\n        if (value && typeof value === 'object')\n            value = doc.createNode(value);\n    }\n    ctx.implicitKey = false;\n    if (!explicitKey && !keyComment && isScalar(value))\n        ctx.indentAtStart = str.length + 1;\n    chompKeep = false;\n    if (!indentSeq &&\n        indentStep.length >= 2 &&\n        !ctx.inFlow &&\n        !explicitKey &&\n        isSeq(value) &&\n        !value.flow &&\n        !value.tag &&\n        !value.anchor) {\n        // If indentSeq === false, consider '- ' as part of indentation where possible\n        ctx.indent = ctx.indent.substring(2);\n    }\n    let valueCommentDone = false;\n    const valueStr = stringify(value, ctx, () => (valueCommentDone = true), () => (chompKeep = true));\n    let ws = ' ';\n    if (keyComment || vsb || vcb) {\n        ws = vsb ? '\\n' : '';\n        if (vcb) {\n            const cs = commentString(vcb);\n            ws += `\\n${indentComment(cs, ctx.indent)}`;\n        }\n        if (valueStr === '' && !ctx.inFlow) {\n            if (ws === '\\n')\n                ws = '\\n\\n';\n        }\n        else {\n            ws += `\\n${ctx.indent}`;\n        }\n    }\n    else if (!explicitKey && isCollection(value)) {\n        const vs0 = valueStr[0];\n        const nl0 = valueStr.indexOf('\\n');\n        const hasNewline = nl0 !== -1;\n        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;\n        if (hasNewline || !flow) {\n            let hasPropsLine = false;\n            if (hasNewline && (vs0 === '&' || vs0 === '!')) {\n                let sp0 = valueStr.indexOf(' ');\n                if (vs0 === '&' &&\n                    sp0 !== -1 &&\n                    sp0 < nl0 &&\n                    valueStr[sp0 + 1] === '!') {\n                    sp0 = valueStr.indexOf(' ', sp0 + 1);\n                }\n                if (sp0 === -1 || nl0 < sp0)\n                    hasPropsLine = true;\n            }\n            if (!hasPropsLine)\n                ws = `\\n${ctx.indent}`;\n        }\n    }\n    else if (valueStr === '' || valueStr[0] === '\\n') {\n        ws = '';\n    }\n    str += ws + valueStr;\n    if (ctx.inFlow) {\n        if (valueCommentDone && onComment)\n            onComment();\n    }\n    else if (valueComment && !valueCommentDone) {\n        str += lineComment(str, ctx.indent, commentString(valueComment));\n    }\n    else if (chompKeep && onChompKeep) {\n        onChompKeep();\n    }\n    return str;\n}\n\nexport { stringifyPair };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}