{"ast":null,"code":"import { SCALAR, isScalar } from '../nodes/identity.js';\nimport { Scalar } from '../nodes/Scalar.js';\nimport { resolveBlockScalar } from './resolve-block-scalar.js';\nimport { resolveFlowScalar } from './resolve-flow-scalar.js';\nfunction composeScalar(ctx, token, tagToken, onError) {\n  const {\n    value,\n    type,\n    comment,\n    range\n  } = token.type === 'block-scalar' ? resolveBlockScalar(token, ctx.options.strict, onError) : resolveFlowScalar(token, ctx.options.strict, onError);\n  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg)) : null;\n  const tag = tagToken && tagName ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError) : token.type === 'scalar' ? findScalarTagByTest(ctx, value, token, onError) : ctx.schema[SCALAR];\n  let scalar;\n  try {\n    const res = tag.resolve(value, msg => onError(tagToken !== null && tagToken !== void 0 ? tagToken : token, 'TAG_RESOLVE_FAILED', msg), ctx.options);\n    scalar = isScalar(res) ? res : new Scalar(res);\n  } catch (error) {\n    const msg = error instanceof Error ? error.message : String(error);\n    onError(tagToken !== null && tagToken !== void 0 ? tagToken : token, 'TAG_RESOLVE_FAILED', msg);\n    scalar = new Scalar(value);\n  }\n  scalar.range = range;\n  scalar.source = value;\n  if (type) scalar.type = type;\n  if (tagName) scalar.tag = tagName;\n  if (tag.format) scalar.format = tag.format;\n  if (comment) scalar.comment = comment;\n  return scalar;\n}\nfunction findScalarTagByName(schema, value, tagName, tagToken, onError) {\n  if (tagName === '!') return schema[SCALAR]; // non-specific tag\n  const matchWithTest = [];\n  for (const tag of schema.tags) {\n    if (!tag.collection && tag.tag === tagName) {\n      if (tag.default && tag.test) matchWithTest.push(tag);else return tag;\n    }\n  }\n  for (const tag of matchWithTest) {\n    var _tag$test;\n    if ((_tag$test = tag.test) !== null && _tag$test !== void 0 && _tag$test.test(value)) return tag;\n  }\n  const kt = schema.knownTags[tagName];\n  if (kt && !kt.collection) {\n    // Ensure that the known tag is available for stringifying,\n    // but does not get used by default.\n    schema.tags.push(Object.assign({}, kt, {\n      default: false,\n      test: undefined\n    }));\n    return kt;\n  }\n  onError(tagToken, 'TAG_RESOLVE_FAILED', \"Unresolved tag: \".concat(tagName), tagName !== 'tag:yaml.org,2002:str');\n  return schema[SCALAR];\n}\nfunction findScalarTagByTest(_ref, value, token, onError) {\n  let {\n    directives,\n    schema\n  } = _ref;\n  const tag = schema.tags.find(tag => {\n    var _tag$test2;\n    return tag.default && ((_tag$test2 = tag.test) === null || _tag$test2 === void 0 ? void 0 : _tag$test2.test(value));\n  }) || schema[SCALAR];\n  if (schema.compat) {\n    var _schema$compat$find;\n    const compat = (_schema$compat$find = schema.compat.find(tag => {\n      var _tag$test3;\n      return tag.default && ((_tag$test3 = tag.test) === null || _tag$test3 === void 0 ? void 0 : _tag$test3.test(value));\n    })) !== null && _schema$compat$find !== void 0 ? _schema$compat$find : schema[SCALAR];\n    if (tag.tag !== compat.tag) {\n      const ts = directives.tagString(tag.tag);\n      const cs = directives.tagString(compat.tag);\n      const msg = \"Value may be parsed as either \".concat(ts, \" or \").concat(cs);\n      onError(token, 'TAG_RESOLVE_FAILED', msg, true);\n    }\n  }\n  return tag;\n}\nexport { composeScalar };","map":{"version":3,"names":["SCALAR","isScalar","Scalar","resolveBlockScalar","resolveFlowScalar","composeScalar","ctx","token","tagToken","onError","value","type","comment","range","options","strict","tagName","directives","source","msg","tag","findScalarTagByName","schema","findScalarTagByTest","scalar","res","resolve","error","Error","message","String","format","matchWithTest","tags","collection","default","test","push","_tag$test","kt","knownTags","Object","assign","undefined","concat","_ref","find","_tag$test2","compat","_schema$compat$find","_tag$test3","ts","tagString","cs"],"sources":["/Users/shoukaiwen/WebstormProjects/alluxio-k8s-operator-ui/node_modules/yaml/browser/dist/compose/compose-scalar.js"],"sourcesContent":["import { SCALAR, isScalar } from '../nodes/identity.js';\nimport { Scalar } from '../nodes/Scalar.js';\nimport { resolveBlockScalar } from './resolve-block-scalar.js';\nimport { resolveFlowScalar } from './resolve-flow-scalar.js';\n\nfunction composeScalar(ctx, token, tagToken, onError) {\n    const { value, type, comment, range } = token.type === 'block-scalar'\n        ? resolveBlockScalar(token, ctx.options.strict, onError)\n        : resolveFlowScalar(token, ctx.options.strict, onError);\n    const tagName = tagToken\n        ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))\n        : null;\n    const tag = tagToken && tagName\n        ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError)\n        : token.type === 'scalar'\n            ? findScalarTagByTest(ctx, value, token, onError)\n            : ctx.schema[SCALAR];\n    let scalar;\n    try {\n        const res = tag.resolve(value, msg => onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg), ctx.options);\n        scalar = isScalar(res) ? res : new Scalar(res);\n    }\n    catch (error) {\n        const msg = error instanceof Error ? error.message : String(error);\n        onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg);\n        scalar = new Scalar(value);\n    }\n    scalar.range = range;\n    scalar.source = value;\n    if (type)\n        scalar.type = type;\n    if (tagName)\n        scalar.tag = tagName;\n    if (tag.format)\n        scalar.format = tag.format;\n    if (comment)\n        scalar.comment = comment;\n    return scalar;\n}\nfunction findScalarTagByName(schema, value, tagName, tagToken, onError) {\n    if (tagName === '!')\n        return schema[SCALAR]; // non-specific tag\n    const matchWithTest = [];\n    for (const tag of schema.tags) {\n        if (!tag.collection && tag.tag === tagName) {\n            if (tag.default && tag.test)\n                matchWithTest.push(tag);\n            else\n                return tag;\n        }\n    }\n    for (const tag of matchWithTest)\n        if (tag.test?.test(value))\n            return tag;\n    const kt = schema.knownTags[tagName];\n    if (kt && !kt.collection) {\n        // Ensure that the known tag is available for stringifying,\n        // but does not get used by default.\n        schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));\n        return kt;\n    }\n    onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');\n    return schema[SCALAR];\n}\nfunction findScalarTagByTest({ directives, schema }, value, token, onError) {\n    const tag = schema.tags.find(tag => tag.default && tag.test?.test(value)) || schema[SCALAR];\n    if (schema.compat) {\n        const compat = schema.compat.find(tag => tag.default && tag.test?.test(value)) ??\n            schema[SCALAR];\n        if (tag.tag !== compat.tag) {\n            const ts = directives.tagString(tag.tag);\n            const cs = directives.tagString(compat.tag);\n            const msg = `Value may be parsed as either ${ts} or ${cs}`;\n            onError(token, 'TAG_RESOLVE_FAILED', msg, true);\n        }\n    }\n    return tag;\n}\n\nexport { composeScalar };\n"],"mappings":"AAAA,SAASA,MAAM,EAAEC,QAAQ,QAAQ,sBAAsB;AACvD,SAASC,MAAM,QAAQ,oBAAoB;AAC3C,SAASC,kBAAkB,QAAQ,2BAA2B;AAC9D,SAASC,iBAAiB,QAAQ,0BAA0B;AAE5D,SAASC,aAAaA,CAACC,GAAG,EAAEC,KAAK,EAAEC,QAAQ,EAAEC,OAAO,EAAE;EAClD,MAAM;IAAEC,KAAK;IAAEC,IAAI;IAAEC,OAAO;IAAEC;EAAM,CAAC,GAAGN,KAAK,CAACI,IAAI,KAAK,cAAc,GAC/DR,kBAAkB,CAACI,KAAK,EAAED,GAAG,CAACQ,OAAO,CAACC,MAAM,EAAEN,OAAO,CAAC,GACtDL,iBAAiB,CAACG,KAAK,EAAED,GAAG,CAACQ,OAAO,CAACC,MAAM,EAAEN,OAAO,CAAC;EAC3D,MAAMO,OAAO,GAAGR,QAAQ,GAClBF,GAAG,CAACW,UAAU,CAACD,OAAO,CAACR,QAAQ,CAACU,MAAM,EAAEC,GAAG,IAAIV,OAAO,CAACD,QAAQ,EAAE,oBAAoB,EAAEW,GAAG,CAAC,CAAC,GAC5F,IAAI;EACV,MAAMC,GAAG,GAAGZ,QAAQ,IAAIQ,OAAO,GACzBK,mBAAmB,CAACf,GAAG,CAACgB,MAAM,EAAEZ,KAAK,EAAEM,OAAO,EAAER,QAAQ,EAAEC,OAAO,CAAC,GAClEF,KAAK,CAACI,IAAI,KAAK,QAAQ,GACnBY,mBAAmB,CAACjB,GAAG,EAAEI,KAAK,EAAEH,KAAK,EAAEE,OAAO,CAAC,GAC/CH,GAAG,CAACgB,MAAM,CAACtB,MAAM,CAAC;EAC5B,IAAIwB,MAAM;EACV,IAAI;IACA,MAAMC,GAAG,GAAGL,GAAG,CAACM,OAAO,CAAChB,KAAK,EAAES,GAAG,IAAIV,OAAO,CAACD,QAAQ,aAARA,QAAQ,cAARA,QAAQ,GAAID,KAAK,EAAE,oBAAoB,EAAEY,GAAG,CAAC,EAAEb,GAAG,CAACQ,OAAO,CAAC;IACzGU,MAAM,GAAGvB,QAAQ,CAACwB,GAAG,CAAC,GAAGA,GAAG,GAAG,IAAIvB,MAAM,CAACuB,GAAG,CAAC;EAClD,CAAC,CACD,OAAOE,KAAK,EAAE;IACV,MAAMR,GAAG,GAAGQ,KAAK,YAAYC,KAAK,GAAGD,KAAK,CAACE,OAAO,GAAGC,MAAM,CAACH,KAAK,CAAC;IAClElB,OAAO,CAACD,QAAQ,aAARA,QAAQ,cAARA,QAAQ,GAAID,KAAK,EAAE,oBAAoB,EAAEY,GAAG,CAAC;IACrDK,MAAM,GAAG,IAAItB,MAAM,CAACQ,KAAK,CAAC;EAC9B;EACAc,MAAM,CAACX,KAAK,GAAGA,KAAK;EACpBW,MAAM,CAACN,MAAM,GAAGR,KAAK;EACrB,IAAIC,IAAI,EACJa,MAAM,CAACb,IAAI,GAAGA,IAAI;EACtB,IAAIK,OAAO,EACPQ,MAAM,CAACJ,GAAG,GAAGJ,OAAO;EACxB,IAAII,GAAG,CAACW,MAAM,EACVP,MAAM,CAACO,MAAM,GAAGX,GAAG,CAACW,MAAM;EAC9B,IAAInB,OAAO,EACPY,MAAM,CAACZ,OAAO,GAAGA,OAAO;EAC5B,OAAOY,MAAM;AACjB;AACA,SAASH,mBAAmBA,CAACC,MAAM,EAAEZ,KAAK,EAAEM,OAAO,EAAER,QAAQ,EAAEC,OAAO,EAAE;EACpE,IAAIO,OAAO,KAAK,GAAG,EACf,OAAOM,MAAM,CAACtB,MAAM,CAAC,CAAC,CAAC;EAC3B,MAAMgC,aAAa,GAAG,EAAE;EACxB,KAAK,MAAMZ,GAAG,IAAIE,MAAM,CAACW,IAAI,EAAE;IAC3B,IAAI,CAACb,GAAG,CAACc,UAAU,IAAId,GAAG,CAACA,GAAG,KAAKJ,OAAO,EAAE;MACxC,IAAII,GAAG,CAACe,OAAO,IAAIf,GAAG,CAACgB,IAAI,EACvBJ,aAAa,CAACK,IAAI,CAACjB,GAAG,CAAC,CAAC,KAExB,OAAOA,GAAG;IAClB;EACJ;EACA,KAAK,MAAMA,GAAG,IAAIY,aAAa;IAAA,IAAAM,SAAA;IAC3B,KAAAA,SAAA,GAAIlB,GAAG,CAACgB,IAAI,cAAAE,SAAA,eAARA,SAAA,CAAUF,IAAI,CAAC1B,KAAK,CAAC,EACrB,OAAOU,GAAG;EAAC;EACnB,MAAMmB,EAAE,GAAGjB,MAAM,CAACkB,SAAS,CAACxB,OAAO,CAAC;EACpC,IAAIuB,EAAE,IAAI,CAACA,EAAE,CAACL,UAAU,EAAE;IACtB;IACA;IACAZ,MAAM,CAACW,IAAI,CAACI,IAAI,CAACI,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEH,EAAE,EAAE;MAAEJ,OAAO,EAAE,KAAK;MAAEC,IAAI,EAAEO;IAAU,CAAC,CAAC,CAAC;IAC5E,OAAOJ,EAAE;EACb;EACA9B,OAAO,CAACD,QAAQ,EAAE,oBAAoB,qBAAAoC,MAAA,CAAqB5B,OAAO,GAAIA,OAAO,KAAK,uBAAuB,CAAC;EAC1G,OAAOM,MAAM,CAACtB,MAAM,CAAC;AACzB;AACA,SAASuB,mBAAmBA,CAAAsB,IAAA,EAAyBnC,KAAK,EAAEH,KAAK,EAAEE,OAAO,EAAE;EAAA,IAA/C;IAAEQ,UAAU;IAAEK;EAAO,CAAC,GAAAuB,IAAA;EAC/C,MAAMzB,GAAG,GAAGE,MAAM,CAACW,IAAI,CAACa,IAAI,CAAC1B,GAAG;IAAA,IAAA2B,UAAA;IAAA,OAAI3B,GAAG,CAACe,OAAO,MAAAY,UAAA,GAAI3B,GAAG,CAACgB,IAAI,cAAAW,UAAA,uBAARA,UAAA,CAAUX,IAAI,CAAC1B,KAAK,CAAC;EAAA,EAAC,IAAIY,MAAM,CAACtB,MAAM,CAAC;EAC3F,IAAIsB,MAAM,CAAC0B,MAAM,EAAE;IAAA,IAAAC,mBAAA;IACf,MAAMD,MAAM,IAAAC,mBAAA,GAAG3B,MAAM,CAAC0B,MAAM,CAACF,IAAI,CAAC1B,GAAG;MAAA,IAAA8B,UAAA;MAAA,OAAI9B,GAAG,CAACe,OAAO,MAAAe,UAAA,GAAI9B,GAAG,CAACgB,IAAI,cAAAc,UAAA,uBAARA,UAAA,CAAUd,IAAI,CAAC1B,KAAK,CAAC;IAAA,EAAC,cAAAuC,mBAAA,cAAAA,mBAAA,GAC1E3B,MAAM,CAACtB,MAAM,CAAC;IAClB,IAAIoB,GAAG,CAACA,GAAG,KAAK4B,MAAM,CAAC5B,GAAG,EAAE;MACxB,MAAM+B,EAAE,GAAGlC,UAAU,CAACmC,SAAS,CAAChC,GAAG,CAACA,GAAG,CAAC;MACxC,MAAMiC,EAAE,GAAGpC,UAAU,CAACmC,SAAS,CAACJ,MAAM,CAAC5B,GAAG,CAAC;MAC3C,MAAMD,GAAG,oCAAAyB,MAAA,CAAoCO,EAAE,UAAAP,MAAA,CAAOS,EAAE,CAAE;MAC1D5C,OAAO,CAACF,KAAK,EAAE,oBAAoB,EAAEY,GAAG,EAAE,IAAI,CAAC;IACnD;EACJ;EACA,OAAOC,GAAG;AACd;AAEA,SAASf,aAAa"},"metadata":{},"sourceType":"module","externalDependencies":[]}