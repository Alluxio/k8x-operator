{"ast":null,"code":"import { Scalar } from '../nodes/Scalar.js';\nimport { resolveEnd } from './resolve-end.js';\nfunction resolveFlowScalar(scalar, strict, onError) {\n  const {\n    offset,\n    type,\n    source,\n    end\n  } = scalar;\n  let _type;\n  let value;\n  const _onError = (rel, code, msg) => onError(offset + rel, code, msg);\n  switch (type) {\n    case 'scalar':\n      _type = Scalar.PLAIN;\n      value = plainValue(source, _onError);\n      break;\n    case 'single-quoted-scalar':\n      _type = Scalar.QUOTE_SINGLE;\n      value = singleQuotedValue(source, _onError);\n      break;\n    case 'double-quoted-scalar':\n      _type = Scalar.QUOTE_DOUBLE;\n      value = doubleQuotedValue(source, _onError);\n      break;\n    /* istanbul ignore next should not happen */\n    default:\n      onError(scalar, 'UNEXPECTED_TOKEN', \"Expected a flow scalar value, but found: \".concat(type));\n      return {\n        value: '',\n        type: null,\n        comment: '',\n        range: [offset, offset + source.length, offset + source.length]\n      };\n  }\n  const valueEnd = offset + source.length;\n  const re = resolveEnd(end, valueEnd, strict, onError);\n  return {\n    value,\n    type: _type,\n    comment: re.comment,\n    range: [offset, valueEnd, re.offset]\n  };\n}\nfunction plainValue(source, onError) {\n  let badChar = '';\n  switch (source[0]) {\n    /* istanbul ignore next should not happen */\n    case '\\t':\n      badChar = 'a tab character';\n      break;\n    case ',':\n      badChar = 'flow indicator character ,';\n      break;\n    case '%':\n      badChar = 'directive indicator character %';\n      break;\n    case '|':\n    case '>':\n      {\n        badChar = \"block scalar indicator \".concat(source[0]);\n        break;\n      }\n    case '@':\n    case '`':\n      {\n        badChar = \"reserved character \".concat(source[0]);\n        break;\n      }\n  }\n  if (badChar) onError(0, 'BAD_SCALAR_START', \"Plain value cannot start with \".concat(badChar));\n  return foldLines(source);\n}\nfunction singleQuotedValue(source, onError) {\n  if (source[source.length - 1] !== \"'\" || source.length === 1) onError(source.length, 'MISSING_CHAR', \"Missing closing 'quote\");\n  return foldLines(source.slice(1, -1)).replace(/''/g, \"'\");\n}\nfunction foldLines(source) {\n  var _match$, _match;\n  /**\n   * The negative lookbehind here and in the `re` RegExp is to\n   * prevent causing a polynomial search time in certain cases.\n   *\n   * The try-catch is for Safari, which doesn't support this yet:\n   * https://caniuse.com/js-regexp-lookbehind\n   */\n  let first, line;\n  try {\n    first = new RegExp('(.*?)(?<![ \\t])[ \\t]*\\r?\\n', 'sy');\n    line = new RegExp('[ \\t]*(.*?)(?:(?<![ \\t])[ \\t]*)?\\r?\\n', 'sy');\n  } catch (_) {\n    first = /(.*?)[ \\t]*\\r?\\n/sy;\n    line = /[ \\t]*(.*?)[ \\t]*\\r?\\n/sy;\n  }\n  let match = first.exec(source);\n  if (!match) return source;\n  let res = match[1];\n  let sep = ' ';\n  let pos = first.lastIndex;\n  line.lastIndex = pos;\n  while (match = line.exec(source)) {\n    if (match[1] === '') {\n      if (sep === '\\n') res += sep;else sep = '\\n';\n    } else {\n      res += sep + match[1];\n      sep = ' ';\n    }\n    pos = line.lastIndex;\n  }\n  const last = /[ \\t]*(.*)/sy;\n  last.lastIndex = pos;\n  match = last.exec(source);\n  return res + sep + ((_match$ = (_match = match) === null || _match === void 0 ? void 0 : _match[1]) !== null && _match$ !== void 0 ? _match$ : '');\n}\nfunction doubleQuotedValue(source, onError) {\n  let res = '';\n  for (let i = 1; i < source.length - 1; ++i) {\n    const ch = source[i];\n    if (ch === '\\r' && source[i + 1] === '\\n') continue;\n    if (ch === '\\n') {\n      const {\n        fold,\n        offset\n      } = foldNewline(source, i);\n      res += fold;\n      i = offset;\n    } else if (ch === '\\\\') {\n      let next = source[++i];\n      const cc = escapeCodes[next];\n      if (cc) res += cc;else if (next === '\\n') {\n        // skip escaped newlines, but still trim the following line\n        next = source[i + 1];\n        while (next === ' ' || next === '\\t') next = source[++i + 1];\n      } else if (next === '\\r' && source[i + 1] === '\\n') {\n        // skip escaped CRLF newlines, but still trim the following line\n        next = source[++i + 1];\n        while (next === ' ' || next === '\\t') next = source[++i + 1];\n      } else if (next === 'x' || next === 'u' || next === 'U') {\n        const length = {\n          x: 2,\n          u: 4,\n          U: 8\n        }[next];\n        res += parseCharCode(source, i + 1, length, onError);\n        i += length;\n      } else {\n        const raw = source.substr(i - 1, 2);\n        onError(i - 1, 'BAD_DQ_ESCAPE', \"Invalid escape sequence \".concat(raw));\n        res += raw;\n      }\n    } else if (ch === ' ' || ch === '\\t') {\n      // trim trailing whitespace\n      const wsStart = i;\n      let next = source[i + 1];\n      while (next === ' ' || next === '\\t') next = source[++i + 1];\n      if (next !== '\\n' && !(next === '\\r' && source[i + 2] === '\\n')) res += i > wsStart ? source.slice(wsStart, i + 1) : ch;\n    } else {\n      res += ch;\n    }\n  }\n  if (source[source.length - 1] !== '\"' || source.length === 1) onError(source.length, 'MISSING_CHAR', 'Missing closing \"quote');\n  return res;\n}\n/**\n * Fold a single newline into a space, multiple newlines to N - 1 newlines.\n * Presumes `source[offset] === '\\n'`\n */\nfunction foldNewline(source, offset) {\n  let fold = '';\n  let ch = source[offset + 1];\n  while (ch === ' ' || ch === '\\t' || ch === '\\n' || ch === '\\r') {\n    if (ch === '\\r' && source[offset + 2] !== '\\n') break;\n    if (ch === '\\n') fold += '\\n';\n    offset += 1;\n    ch = source[offset + 1];\n  }\n  if (!fold) fold = ' ';\n  return {\n    fold,\n    offset\n  };\n}\nconst escapeCodes = {\n  '0': '\\0',\n  a: '\\x07',\n  b: '\\b',\n  e: '\\x1b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t',\n  v: '\\v',\n  N: '\\u0085',\n  _: '\\u00a0',\n  L: '\\u2028',\n  P: '\\u2029',\n  ' ': ' ',\n  '\"': '\"',\n  '/': '/',\n  '\\\\': '\\\\',\n  '\\t': '\\t'\n};\nfunction parseCharCode(source, offset, length, onError) {\n  const cc = source.substr(offset, length);\n  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n  const code = ok ? parseInt(cc, 16) : NaN;\n  if (isNaN(code)) {\n    const raw = source.substr(offset - 2, length + 2);\n    onError(offset - 2, 'BAD_DQ_ESCAPE', \"Invalid escape sequence \".concat(raw));\n    return raw;\n  }\n  return String.fromCodePoint(code);\n}\nexport { resolveFlowScalar };","map":{"version":3,"names":["Scalar","resolveEnd","resolveFlowScalar","scalar","strict","onError","offset","type","source","end","_type","value","_onError","rel","code","msg","PLAIN","plainValue","QUOTE_SINGLE","singleQuotedValue","QUOTE_DOUBLE","doubleQuotedValue","concat","comment","range","length","valueEnd","re","badChar","foldLines","slice","replace","_match$","_match","first","line","RegExp","_","match","exec","res","sep","pos","lastIndex","last","i","ch","fold","foldNewline","next","cc","escapeCodes","x","u","U","parseCharCode","raw","substr","wsStart","a","b","e","f","n","r","t","v","N","L","P","ok","test","parseInt","NaN","isNaN","String","fromCodePoint"],"sources":["/Users/shoukaiwen/WebstormProjects/alluxio-k8s-operator-ui/node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js"],"sourcesContent":["import { Scalar } from '../nodes/Scalar.js';\nimport { resolveEnd } from './resolve-end.js';\n\nfunction resolveFlowScalar(scalar, strict, onError) {\n    const { offset, type, source, end } = scalar;\n    let _type;\n    let value;\n    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);\n    switch (type) {\n        case 'scalar':\n            _type = Scalar.PLAIN;\n            value = plainValue(source, _onError);\n            break;\n        case 'single-quoted-scalar':\n            _type = Scalar.QUOTE_SINGLE;\n            value = singleQuotedValue(source, _onError);\n            break;\n        case 'double-quoted-scalar':\n            _type = Scalar.QUOTE_DOUBLE;\n            value = doubleQuotedValue(source, _onError);\n            break;\n        /* istanbul ignore next should not happen */\n        default:\n            onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);\n            return {\n                value: '',\n                type: null,\n                comment: '',\n                range: [offset, offset + source.length, offset + source.length]\n            };\n    }\n    const valueEnd = offset + source.length;\n    const re = resolveEnd(end, valueEnd, strict, onError);\n    return {\n        value,\n        type: _type,\n        comment: re.comment,\n        range: [offset, valueEnd, re.offset]\n    };\n}\nfunction plainValue(source, onError) {\n    let badChar = '';\n    switch (source[0]) {\n        /* istanbul ignore next should not happen */\n        case '\\t':\n            badChar = 'a tab character';\n            break;\n        case ',':\n            badChar = 'flow indicator character ,';\n            break;\n        case '%':\n            badChar = 'directive indicator character %';\n            break;\n        case '|':\n        case '>': {\n            badChar = `block scalar indicator ${source[0]}`;\n            break;\n        }\n        case '@':\n        case '`': {\n            badChar = `reserved character ${source[0]}`;\n            break;\n        }\n    }\n    if (badChar)\n        onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);\n    return foldLines(source);\n}\nfunction singleQuotedValue(source, onError) {\n    if (source[source.length - 1] !== \"'\" || source.length === 1)\n        onError(source.length, 'MISSING_CHAR', \"Missing closing 'quote\");\n    return foldLines(source.slice(1, -1)).replace(/''/g, \"'\");\n}\nfunction foldLines(source) {\n    /**\n     * The negative lookbehind here and in the `re` RegExp is to\n     * prevent causing a polynomial search time in certain cases.\n     *\n     * The try-catch is for Safari, which doesn't support this yet:\n     * https://caniuse.com/js-regexp-lookbehind\n     */\n    let first, line;\n    try {\n        first = new RegExp('(.*?)(?<![ \\t])[ \\t]*\\r?\\n', 'sy');\n        line = new RegExp('[ \\t]*(.*?)(?:(?<![ \\t])[ \\t]*)?\\r?\\n', 'sy');\n    }\n    catch (_) {\n        first = /(.*?)[ \\t]*\\r?\\n/sy;\n        line = /[ \\t]*(.*?)[ \\t]*\\r?\\n/sy;\n    }\n    let match = first.exec(source);\n    if (!match)\n        return source;\n    let res = match[1];\n    let sep = ' ';\n    let pos = first.lastIndex;\n    line.lastIndex = pos;\n    while ((match = line.exec(source))) {\n        if (match[1] === '') {\n            if (sep === '\\n')\n                res += sep;\n            else\n                sep = '\\n';\n        }\n        else {\n            res += sep + match[1];\n            sep = ' ';\n        }\n        pos = line.lastIndex;\n    }\n    const last = /[ \\t]*(.*)/sy;\n    last.lastIndex = pos;\n    match = last.exec(source);\n    return res + sep + (match?.[1] ?? '');\n}\nfunction doubleQuotedValue(source, onError) {\n    let res = '';\n    for (let i = 1; i < source.length - 1; ++i) {\n        const ch = source[i];\n        if (ch === '\\r' && source[i + 1] === '\\n')\n            continue;\n        if (ch === '\\n') {\n            const { fold, offset } = foldNewline(source, i);\n            res += fold;\n            i = offset;\n        }\n        else if (ch === '\\\\') {\n            let next = source[++i];\n            const cc = escapeCodes[next];\n            if (cc)\n                res += cc;\n            else if (next === '\\n') {\n                // skip escaped newlines, but still trim the following line\n                next = source[i + 1];\n                while (next === ' ' || next === '\\t')\n                    next = source[++i + 1];\n            }\n            else if (next === '\\r' && source[i + 1] === '\\n') {\n                // skip escaped CRLF newlines, but still trim the following line\n                next = source[++i + 1];\n                while (next === ' ' || next === '\\t')\n                    next = source[++i + 1];\n            }\n            else if (next === 'x' || next === 'u' || next === 'U') {\n                const length = { x: 2, u: 4, U: 8 }[next];\n                res += parseCharCode(source, i + 1, length, onError);\n                i += length;\n            }\n            else {\n                const raw = source.substr(i - 1, 2);\n                onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n                res += raw;\n            }\n        }\n        else if (ch === ' ' || ch === '\\t') {\n            // trim trailing whitespace\n            const wsStart = i;\n            let next = source[i + 1];\n            while (next === ' ' || next === '\\t')\n                next = source[++i + 1];\n            if (next !== '\\n' && !(next === '\\r' && source[i + 2] === '\\n'))\n                res += i > wsStart ? source.slice(wsStart, i + 1) : ch;\n        }\n        else {\n            res += ch;\n        }\n    }\n    if (source[source.length - 1] !== '\"' || source.length === 1)\n        onError(source.length, 'MISSING_CHAR', 'Missing closing \"quote');\n    return res;\n}\n/**\n * Fold a single newline into a space, multiple newlines to N - 1 newlines.\n * Presumes `source[offset] === '\\n'`\n */\nfunction foldNewline(source, offset) {\n    let fold = '';\n    let ch = source[offset + 1];\n    while (ch === ' ' || ch === '\\t' || ch === '\\n' || ch === '\\r') {\n        if (ch === '\\r' && source[offset + 2] !== '\\n')\n            break;\n        if (ch === '\\n')\n            fold += '\\n';\n        offset += 1;\n        ch = source[offset + 1];\n    }\n    if (!fold)\n        fold = ' ';\n    return { fold, offset };\n}\nconst escapeCodes = {\n    '0': '\\0',\n    a: '\\x07',\n    b: '\\b',\n    e: '\\x1b',\n    f: '\\f',\n    n: '\\n',\n    r: '\\r',\n    t: '\\t',\n    v: '\\v',\n    N: '\\u0085',\n    _: '\\u00a0',\n    L: '\\u2028',\n    P: '\\u2029',\n    ' ': ' ',\n    '\"': '\"',\n    '/': '/',\n    '\\\\': '\\\\',\n    '\\t': '\\t'\n};\nfunction parseCharCode(source, offset, length, onError) {\n    const cc = source.substr(offset, length);\n    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n    const code = ok ? parseInt(cc, 16) : NaN;\n    if (isNaN(code)) {\n        const raw = source.substr(offset - 2, length + 2);\n        onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n        return raw;\n    }\n    return String.fromCodePoint(code);\n}\n\nexport { resolveFlowScalar };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}