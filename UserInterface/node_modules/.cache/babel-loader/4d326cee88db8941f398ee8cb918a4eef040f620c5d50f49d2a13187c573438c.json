{"ast":null,"code":"import { Alias } from '../nodes/Alias.js';\nimport { isEmptyPath, collectionFromPath } from '../nodes/Collection.js';\nimport { NODE_TYPE, DOC, isNode, isCollection, isScalar } from '../nodes/identity.js';\nimport { Pair } from '../nodes/Pair.js';\nimport { toJS } from '../nodes/toJS.js';\nimport { Schema } from '../schema/Schema.js';\nimport { stringifyDocument } from '../stringify/stringifyDocument.js';\nimport { anchorNames, findNewAnchor, createNodeAnchors } from './anchors.js';\nimport { applyReviver } from './applyReviver.js';\nimport { createNode } from './createNode.js';\nimport { Directives } from './directives.js';\nclass Document {\n  constructor(value, replacer, options) {\n    var _options;\n    /** A comment before this Document */\n    this.commentBefore = null;\n    /** A comment immediately after this Document */\n    this.comment = null;\n    /** Errors encountered during parsing. */\n    this.errors = [];\n    /** Warnings encountered during parsing. */\n    this.warnings = [];\n    Object.defineProperty(this, NODE_TYPE, {\n      value: DOC\n    });\n    let _replacer = null;\n    if (typeof replacer === 'function' || Array.isArray(replacer)) {\n      _replacer = replacer;\n    } else if (options === undefined && replacer) {\n      options = replacer;\n      replacer = undefined;\n    }\n    const opt = Object.assign({\n      intAsBigInt: false,\n      keepSourceTokens: false,\n      logLevel: 'warn',\n      prettyErrors: true,\n      strict: true,\n      uniqueKeys: true,\n      version: '1.2'\n    }, options);\n    this.options = opt;\n    let {\n      version\n    } = opt;\n    if ((_options = options) !== null && _options !== void 0 && _options._directives) {\n      this.directives = options._directives.atDocument();\n      if (this.directives.yaml.explicit) version = this.directives.yaml.version;\n    } else this.directives = new Directives({\n      version\n    });\n    this.setSchema(version, options);\n    // @ts-expect-error We can't really know that this matches Contents.\n    this.contents = value === undefined ? null : this.createNode(value, _replacer, options);\n  }\n  /**\n   * Create a deep copy of this Document and its contents.\n   *\n   * Custom Node values that inherit from `Object` still refer to their original instances.\n   */\n  clone() {\n    const copy = Object.create(Document.prototype, {\n      [NODE_TYPE]: {\n        value: DOC\n      }\n    });\n    copy.commentBefore = this.commentBefore;\n    copy.comment = this.comment;\n    copy.errors = this.errors.slice();\n    copy.warnings = this.warnings.slice();\n    copy.options = Object.assign({}, this.options);\n    if (this.directives) copy.directives = this.directives.clone();\n    copy.schema = this.schema.clone();\n    // @ts-expect-error We can't really know that this matches Contents.\n    copy.contents = isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;\n    if (this.range) copy.range = this.range.slice();\n    return copy;\n  }\n  /** Adds a value to the document. */\n  add(value) {\n    if (assertCollection(this.contents)) this.contents.add(value);\n  }\n  /** Adds a value to the document. */\n  addIn(path, value) {\n    if (assertCollection(this.contents)) this.contents.addIn(path, value);\n  }\n  /**\n   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.\n   *\n   * If `node` already has an anchor, `name` is ignored.\n   * Otherwise, the `node.anchor` value will be set to `name`,\n   * or if an anchor with that name is already present in the document,\n   * `name` will be used as a prefix for a new unique anchor.\n   * If `name` is undefined, the generated anchor will use 'a' as a prefix.\n   */\n  createAlias(node, name) {\n    if (!node.anchor) {\n      const prev = anchorNames(this);\n      node.anchor =\n      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n      !name || prev.has(name) ? findNewAnchor(name || 'a', prev) : name;\n    }\n    return new Alias(node.anchor);\n  }\n  createNode(value, replacer, options) {\n    var _options2;\n    let _replacer = undefined;\n    if (typeof replacer === 'function') {\n      value = replacer.call({\n        '': value\n      }, '', value);\n      _replacer = replacer;\n    } else if (Array.isArray(replacer)) {\n      const keyToStr = v => typeof v === 'number' || v instanceof String || v instanceof Number;\n      const asStr = replacer.filter(keyToStr).map(String);\n      if (asStr.length > 0) replacer = replacer.concat(asStr);\n      _replacer = replacer;\n    } else if (options === undefined && replacer) {\n      options = replacer;\n      replacer = undefined;\n    }\n    const {\n      aliasDuplicateObjects,\n      anchorPrefix,\n      flow,\n      keepUndefined,\n      onTagObj,\n      tag\n    } = (_options2 = options) !== null && _options2 !== void 0 ? _options2 : {};\n    const {\n      onAnchor,\n      setAnchors,\n      sourceObjects\n    } = createNodeAnchors(this,\n    // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n    anchorPrefix || 'a');\n    const ctx = {\n      aliasDuplicateObjects: aliasDuplicateObjects !== null && aliasDuplicateObjects !== void 0 ? aliasDuplicateObjects : true,\n      keepUndefined: keepUndefined !== null && keepUndefined !== void 0 ? keepUndefined : false,\n      onAnchor,\n      onTagObj,\n      replacer: _replacer,\n      schema: this.schema,\n      sourceObjects\n    };\n    const node = createNode(value, tag, ctx);\n    if (flow && isCollection(node)) node.flow = true;\n    setAnchors();\n    return node;\n  }\n  /**\n   * Convert a key and a value into a `Pair` using the current schema,\n   * recursively wrapping all values as `Scalar` or `Collection` nodes.\n   */\n  createPair(key, value) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const k = this.createNode(key, null, options);\n    const v = this.createNode(value, null, options);\n    return new Pair(k, v);\n  }\n  /**\n   * Removes a value from the document.\n   * @returns `true` if the item was found and removed.\n   */\n  delete(key) {\n    return assertCollection(this.contents) ? this.contents.delete(key) : false;\n  }\n  /**\n   * Removes a value from the document.\n   * @returns `true` if the item was found and removed.\n   */\n  deleteIn(path) {\n    if (isEmptyPath(path)) {\n      if (this.contents == null) return false;\n      // @ts-expect-error Presumed impossible if Strict extends false\n      this.contents = null;\n      return true;\n    }\n    return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;\n  }\n  /**\n   * Returns item at `key`, or `undefined` if not found. By default unwraps\n   * scalar values from their surrounding node; to disable set `keepScalar` to\n   * `true` (collections are always returned intact).\n   */\n  get(key, keepScalar) {\n    return isCollection(this.contents) ? this.contents.get(key, keepScalar) : undefined;\n  }\n  /**\n   * Returns item at `path`, or `undefined` if not found. By default unwraps\n   * scalar values from their surrounding node; to disable set `keepScalar` to\n   * `true` (collections are always returned intact).\n   */\n  getIn(path, keepScalar) {\n    if (isEmptyPath(path)) return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;\n    return isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : undefined;\n  }\n  /**\n   * Checks if the document includes a value with the key `key`.\n   */\n  has(key) {\n    return isCollection(this.contents) ? this.contents.has(key) : false;\n  }\n  /**\n   * Checks if the document includes a value at `path`.\n   */\n  hasIn(path) {\n    if (isEmptyPath(path)) return this.contents !== undefined;\n    return isCollection(this.contents) ? this.contents.hasIn(path) : false;\n  }\n  /**\n   * Sets a value in this document. For `!!set`, `value` needs to be a\n   * boolean to add/remove the item from the set.\n   */\n  set(key, value) {\n    if (this.contents == null) {\n      // @ts-expect-error We can't really know that this matches Contents.\n      this.contents = collectionFromPath(this.schema, [key], value);\n    } else if (assertCollection(this.contents)) {\n      this.contents.set(key, value);\n    }\n  }\n  /**\n   * Sets a value in this document. For `!!set`, `value` needs to be a\n   * boolean to add/remove the item from the set.\n   */\n  setIn(path, value) {\n    if (isEmptyPath(path)) {\n      // @ts-expect-error We can't really know that this matches Contents.\n      this.contents = value;\n    } else if (this.contents == null) {\n      // @ts-expect-error We can't really know that this matches Contents.\n      this.contents = collectionFromPath(this.schema, Array.from(path), value);\n    } else if (assertCollection(this.contents)) {\n      this.contents.setIn(path, value);\n    }\n  }\n  /**\n   * Change the YAML version and schema used by the document.\n   * A `null` version disables support for directives, explicit tags, anchors, and aliases.\n   * It also requires the `schema` option to be given as a `Schema` instance value.\n   *\n   * Overrides all previously set schema options.\n   */\n  setSchema(version) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (typeof version === 'number') version = String(version);\n    let opt;\n    switch (version) {\n      case '1.1':\n        if (this.directives) this.directives.yaml.version = '1.1';else this.directives = new Directives({\n          version: '1.1'\n        });\n        opt = {\n          merge: true,\n          resolveKnownTags: false,\n          schema: 'yaml-1.1'\n        };\n        break;\n      case '1.2':\n      case 'next':\n        if (this.directives) this.directives.yaml.version = version;else this.directives = new Directives({\n          version\n        });\n        opt = {\n          merge: false,\n          resolveKnownTags: true,\n          schema: 'core'\n        };\n        break;\n      case null:\n        if (this.directives) delete this.directives;\n        opt = null;\n        break;\n      default:\n        {\n          const sv = JSON.stringify(version);\n          throw new Error(\"Expected '1.1', '1.2' or null as first argument, but found: \".concat(sv));\n        }\n    }\n    // Not using `instanceof Schema` to allow for duck typing\n    if (options.schema instanceof Object) this.schema = options.schema;else if (opt) this.schema = new Schema(Object.assign(opt, options));else throw new Error(\"With a null YAML version, the { schema: Schema } option is required\");\n  }\n  // json & jsonArg are only used from toJSON()\n  toJS() {\n    let {\n      json,\n      jsonArg,\n      mapAsMap,\n      maxAliasCount,\n      onAnchor,\n      reviver\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const ctx = {\n      anchors: new Map(),\n      doc: this,\n      keep: !json,\n      mapAsMap: mapAsMap === true,\n      mapKeyWarned: false,\n      maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100\n    };\n    const res = toJS(this.contents, jsonArg !== null && jsonArg !== void 0 ? jsonArg : '', ctx);\n    if (typeof onAnchor === 'function') for (const {\n      count,\n      res\n    } of ctx.anchors.values()) onAnchor(res, count);\n    return typeof reviver === 'function' ? applyReviver(reviver, {\n      '': res\n    }, '', res) : res;\n  }\n  /**\n   * A JSON representation of the document `contents`.\n   *\n   * @param jsonArg Used by `JSON.stringify` to indicate the array index or\n   *   property name.\n   */\n  toJSON(jsonArg, onAnchor) {\n    return this.toJS({\n      json: true,\n      jsonArg,\n      mapAsMap: false,\n      onAnchor\n    });\n  }\n  /** A YAML representation of the document. */\n  toString() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');\n    if ('indent' in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {\n      const s = JSON.stringify(options.indent);\n      throw new Error(\"\\\"indent\\\" option must be a positive integer, not \".concat(s));\n    }\n    return stringifyDocument(this, options);\n  }\n}\nfunction assertCollection(contents) {\n  if (isCollection(contents)) return true;\n  throw new Error('Expected a YAML collection as document contents');\n}\nexport { Document };","map":{"version":3,"names":["Alias","isEmptyPath","collectionFromPath","NODE_TYPE","DOC","isNode","isCollection","isScalar","Pair","toJS","Schema","stringifyDocument","anchorNames","findNewAnchor","createNodeAnchors","applyReviver","createNode","Directives","Document","constructor","value","replacer","options","_options","commentBefore","comment","errors","warnings","Object","defineProperty","_replacer","Array","isArray","undefined","opt","assign","intAsBigInt","keepSourceTokens","logLevel","prettyErrors","strict","uniqueKeys","version","_directives","directives","atDocument","yaml","explicit","setSchema","contents","clone","copy","create","prototype","slice","schema","range","add","assertCollection","addIn","path","createAlias","node","name","anchor","prev","has","_options2","call","keyToStr","v","String","Number","asStr","filter","map","length","concat","aliasDuplicateObjects","anchorPrefix","flow","keepUndefined","onTagObj","tag","onAnchor","setAnchors","sourceObjects","ctx","createPair","key","arguments","k","delete","deleteIn","get","keepScalar","getIn","hasIn","set","setIn","from","merge","resolveKnownTags","sv","JSON","stringify","Error","json","jsonArg","mapAsMap","maxAliasCount","reviver","anchors","Map","doc","keep","mapKeyWarned","res","count","values","toJSON","toString","isInteger","indent","s"],"sources":["/Users/shoukaiwen/WebstormProjects/alluxio-k8s-operator-ui/node_modules/yaml/browser/dist/doc/Document.js"],"sourcesContent":["import { Alias } from '../nodes/Alias.js';\nimport { isEmptyPath, collectionFromPath } from '../nodes/Collection.js';\nimport { NODE_TYPE, DOC, isNode, isCollection, isScalar } from '../nodes/identity.js';\nimport { Pair } from '../nodes/Pair.js';\nimport { toJS } from '../nodes/toJS.js';\nimport { Schema } from '../schema/Schema.js';\nimport { stringifyDocument } from '../stringify/stringifyDocument.js';\nimport { anchorNames, findNewAnchor, createNodeAnchors } from './anchors.js';\nimport { applyReviver } from './applyReviver.js';\nimport { createNode } from './createNode.js';\nimport { Directives } from './directives.js';\n\nclass Document {\n    constructor(value, replacer, options) {\n        /** A comment before this Document */\n        this.commentBefore = null;\n        /** A comment immediately after this Document */\n        this.comment = null;\n        /** Errors encountered during parsing. */\n        this.errors = [];\n        /** Warnings encountered during parsing. */\n        this.warnings = [];\n        Object.defineProperty(this, NODE_TYPE, { value: DOC });\n        let _replacer = null;\n        if (typeof replacer === 'function' || Array.isArray(replacer)) {\n            _replacer = replacer;\n        }\n        else if (options === undefined && replacer) {\n            options = replacer;\n            replacer = undefined;\n        }\n        const opt = Object.assign({\n            intAsBigInt: false,\n            keepSourceTokens: false,\n            logLevel: 'warn',\n            prettyErrors: true,\n            strict: true,\n            uniqueKeys: true,\n            version: '1.2'\n        }, options);\n        this.options = opt;\n        let { version } = opt;\n        if (options?._directives) {\n            this.directives = options._directives.atDocument();\n            if (this.directives.yaml.explicit)\n                version = this.directives.yaml.version;\n        }\n        else\n            this.directives = new Directives({ version });\n        this.setSchema(version, options);\n        // @ts-expect-error We can't really know that this matches Contents.\n        this.contents =\n            value === undefined ? null : this.createNode(value, _replacer, options);\n    }\n    /**\n     * Create a deep copy of this Document and its contents.\n     *\n     * Custom Node values that inherit from `Object` still refer to their original instances.\n     */\n    clone() {\n        const copy = Object.create(Document.prototype, {\n            [NODE_TYPE]: { value: DOC }\n        });\n        copy.commentBefore = this.commentBefore;\n        copy.comment = this.comment;\n        copy.errors = this.errors.slice();\n        copy.warnings = this.warnings.slice();\n        copy.options = Object.assign({}, this.options);\n        if (this.directives)\n            copy.directives = this.directives.clone();\n        copy.schema = this.schema.clone();\n        // @ts-expect-error We can't really know that this matches Contents.\n        copy.contents = isNode(this.contents)\n            ? this.contents.clone(copy.schema)\n            : this.contents;\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /** Adds a value to the document. */\n    add(value) {\n        if (assertCollection(this.contents))\n            this.contents.add(value);\n    }\n    /** Adds a value to the document. */\n    addIn(path, value) {\n        if (assertCollection(this.contents))\n            this.contents.addIn(path, value);\n    }\n    /**\n     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.\n     *\n     * If `node` already has an anchor, `name` is ignored.\n     * Otherwise, the `node.anchor` value will be set to `name`,\n     * or if an anchor with that name is already present in the document,\n     * `name` will be used as a prefix for a new unique anchor.\n     * If `name` is undefined, the generated anchor will use 'a' as a prefix.\n     */\n    createAlias(node, name) {\n        if (!node.anchor) {\n            const prev = anchorNames(this);\n            node.anchor =\n                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n                !name || prev.has(name) ? findNewAnchor(name || 'a', prev) : name;\n        }\n        return new Alias(node.anchor);\n    }\n    createNode(value, replacer, options) {\n        let _replacer = undefined;\n        if (typeof replacer === 'function') {\n            value = replacer.call({ '': value }, '', value);\n            _replacer = replacer;\n        }\n        else if (Array.isArray(replacer)) {\n            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;\n            const asStr = replacer.filter(keyToStr).map(String);\n            if (asStr.length > 0)\n                replacer = replacer.concat(asStr);\n            _replacer = replacer;\n        }\n        else if (options === undefined && replacer) {\n            options = replacer;\n            replacer = undefined;\n        }\n        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};\n        const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(this, \n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        anchorPrefix || 'a');\n        const ctx = {\n            aliasDuplicateObjects: aliasDuplicateObjects ?? true,\n            keepUndefined: keepUndefined ?? false,\n            onAnchor,\n            onTagObj,\n            replacer: _replacer,\n            schema: this.schema,\n            sourceObjects\n        };\n        const node = createNode(value, tag, ctx);\n        if (flow && isCollection(node))\n            node.flow = true;\n        setAnchors();\n        return node;\n    }\n    /**\n     * Convert a key and a value into a `Pair` using the current schema,\n     * recursively wrapping all values as `Scalar` or `Collection` nodes.\n     */\n    createPair(key, value, options = {}) {\n        const k = this.createNode(key, null, options);\n        const v = this.createNode(value, null, options);\n        return new Pair(k, v);\n    }\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    delete(key) {\n        return assertCollection(this.contents) ? this.contents.delete(key) : false;\n    }\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    deleteIn(path) {\n        if (isEmptyPath(path)) {\n            if (this.contents == null)\n                return false;\n            // @ts-expect-error Presumed impossible if Strict extends false\n            this.contents = null;\n            return true;\n        }\n        return assertCollection(this.contents)\n            ? this.contents.deleteIn(path)\n            : false;\n    }\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    get(key, keepScalar) {\n        return isCollection(this.contents)\n            ? this.contents.get(key, keepScalar)\n            : undefined;\n    }\n    /**\n     * Returns item at `path`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    getIn(path, keepScalar) {\n        if (isEmptyPath(path))\n            return !keepScalar && isScalar(this.contents)\n                ? this.contents.value\n                : this.contents;\n        return isCollection(this.contents)\n            ? this.contents.getIn(path, keepScalar)\n            : undefined;\n    }\n    /**\n     * Checks if the document includes a value with the key `key`.\n     */\n    has(key) {\n        return isCollection(this.contents) ? this.contents.has(key) : false;\n    }\n    /**\n     * Checks if the document includes a value at `path`.\n     */\n    hasIn(path) {\n        if (isEmptyPath(path))\n            return this.contents !== undefined;\n        return isCollection(this.contents) ? this.contents.hasIn(path) : false;\n    }\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    set(key, value) {\n        if (this.contents == null) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = collectionFromPath(this.schema, [key], value);\n        }\n        else if (assertCollection(this.contents)) {\n            this.contents.set(key, value);\n        }\n    }\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    setIn(path, value) {\n        if (isEmptyPath(path)) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = value;\n        }\n        else if (this.contents == null) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = collectionFromPath(this.schema, Array.from(path), value);\n        }\n        else if (assertCollection(this.contents)) {\n            this.contents.setIn(path, value);\n        }\n    }\n    /**\n     * Change the YAML version and schema used by the document.\n     * A `null` version disables support for directives, explicit tags, anchors, and aliases.\n     * It also requires the `schema` option to be given as a `Schema` instance value.\n     *\n     * Overrides all previously set schema options.\n     */\n    setSchema(version, options = {}) {\n        if (typeof version === 'number')\n            version = String(version);\n        let opt;\n        switch (version) {\n            case '1.1':\n                if (this.directives)\n                    this.directives.yaml.version = '1.1';\n                else\n                    this.directives = new Directives({ version: '1.1' });\n                opt = { merge: true, resolveKnownTags: false, schema: 'yaml-1.1' };\n                break;\n            case '1.2':\n            case 'next':\n                if (this.directives)\n                    this.directives.yaml.version = version;\n                else\n                    this.directives = new Directives({ version });\n                opt = { merge: false, resolveKnownTags: true, schema: 'core' };\n                break;\n            case null:\n                if (this.directives)\n                    delete this.directives;\n                opt = null;\n                break;\n            default: {\n                const sv = JSON.stringify(version);\n                throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);\n            }\n        }\n        // Not using `instanceof Schema` to allow for duck typing\n        if (options.schema instanceof Object)\n            this.schema = options.schema;\n        else if (opt)\n            this.schema = new Schema(Object.assign(opt, options));\n        else\n            throw new Error(`With a null YAML version, the { schema: Schema } option is required`);\n    }\n    // json & jsonArg are only used from toJSON()\n    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {\n        const ctx = {\n            anchors: new Map(),\n            doc: this,\n            keep: !json,\n            mapAsMap: mapAsMap === true,\n            mapKeyWarned: false,\n            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100\n        };\n        const res = toJS(this.contents, jsonArg ?? '', ctx);\n        if (typeof onAnchor === 'function')\n            for (const { count, res } of ctx.anchors.values())\n                onAnchor(res, count);\n        return typeof reviver === 'function'\n            ? applyReviver(reviver, { '': res }, '', res)\n            : res;\n    }\n    /**\n     * A JSON representation of the document `contents`.\n     *\n     * @param jsonArg Used by `JSON.stringify` to indicate the array index or\n     *   property name.\n     */\n    toJSON(jsonArg, onAnchor) {\n        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });\n    }\n    /** A YAML representation of the document. */\n    toString(options = {}) {\n        if (this.errors.length > 0)\n            throw new Error('Document with errors cannot be stringified');\n        if ('indent' in options &&\n            (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {\n            const s = JSON.stringify(options.indent);\n            throw new Error(`\"indent\" option must be a positive integer, not ${s}`);\n        }\n        return stringifyDocument(this, options);\n    }\n}\nfunction assertCollection(contents) {\n    if (isCollection(contents))\n        return true;\n    throw new Error('Expected a YAML collection as document contents');\n}\n\nexport { Document };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}