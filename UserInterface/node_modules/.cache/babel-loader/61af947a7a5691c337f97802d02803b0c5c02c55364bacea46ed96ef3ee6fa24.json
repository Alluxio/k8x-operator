{"ast":null,"code":"import { stringifyCollection } from '../stringify/stringifyCollection.js';\nimport { addPairToJSMap } from './addPairToJSMap.js';\nimport { Collection } from './Collection.js';\nimport { isPair, isScalar, MAP } from './identity.js';\nimport { Pair, createPair } from './Pair.js';\nimport { isScalarValue } from './Scalar.js';\nfunction findPair(items, key) {\n  const k = isScalar(key) ? key.value : key;\n  for (const it of items) {\n    if (isPair(it)) {\n      if (it.key === key || it.key === k) return it;\n      if (isScalar(it.key) && it.key.value === k) return it;\n    }\n  }\n  return undefined;\n}\nclass YAMLMap extends Collection {\n  static get tagName() {\n    return 'tag:yaml.org,2002:map';\n  }\n  constructor(schema) {\n    super(MAP, schema);\n    this.items = [];\n  }\n  /**\n   * A generic collection parsing method that can be extended\n   * to other node classes that inherit from YAMLMap\n   */\n  static from(schema, obj, ctx) {\n    const {\n      keepUndefined,\n      replacer\n    } = ctx;\n    const map = new this(schema);\n    const add = (key, value) => {\n      if (typeof replacer === 'function') value = replacer.call(obj, key, value);else if (Array.isArray(replacer) && !replacer.includes(key)) return;\n      if (value !== undefined || keepUndefined) map.items.push(createPair(key, value, ctx));\n    };\n    if (obj instanceof Map) {\n      for (const [key, value] of obj) add(key, value);\n    } else if (obj && typeof obj === 'object') {\n      for (const key of Object.keys(obj)) add(key, obj[key]);\n    }\n    if (typeof schema.sortMapEntries === 'function') {\n      map.items.sort(schema.sortMapEntries);\n    }\n    return map;\n  }\n  /**\n   * Adds a value to the collection.\n   *\n   * @param overwrite - If not set `true`, using a key that is already in the\n   *   collection will throw. Otherwise, overwrites the previous value.\n   */\n  add(pair, overwrite) {\n    var _this$schema;\n    let _pair;\n    if (isPair(pair)) _pair = pair;else if (!pair || typeof pair !== 'object' || !('key' in pair)) {\n      // In TypeScript, this never happens.\n      _pair = new Pair(pair, pair === null || pair === void 0 ? void 0 : pair.value);\n    } else _pair = new Pair(pair.key, pair.value);\n    const prev = findPair(this.items, _pair.key);\n    const sortEntries = (_this$schema = this.schema) === null || _this$schema === void 0 ? void 0 : _this$schema.sortMapEntries;\n    if (prev) {\n      if (!overwrite) throw new Error(\"Key \".concat(_pair.key, \" already set\"));\n      // For scalars, keep the old node & its comments and anchors\n      if (isScalar(prev.value) && isScalarValue(_pair.value)) prev.value.value = _pair.value;else prev.value = _pair.value;\n    } else if (sortEntries) {\n      const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);\n      if (i === -1) this.items.push(_pair);else this.items.splice(i, 0, _pair);\n    } else {\n      this.items.push(_pair);\n    }\n  }\n  delete(key) {\n    const it = findPair(this.items, key);\n    if (!it) return false;\n    const del = this.items.splice(this.items.indexOf(it), 1);\n    return del.length > 0;\n  }\n  get(key, keepScalar) {\n    var _ref;\n    const it = findPair(this.items, key);\n    const node = it === null || it === void 0 ? void 0 : it.value;\n    return (_ref = !keepScalar && isScalar(node) ? node.value : node) !== null && _ref !== void 0 ? _ref : undefined;\n  }\n  has(key) {\n    return !!findPair(this.items, key);\n  }\n  set(key, value) {\n    this.add(new Pair(key, value), true);\n  }\n  /**\n   * @param ctx - Conversion context, originally set in Document#toJS()\n   * @param {Class} Type - If set, forces the returned collection type\n   * @returns Instance of Type, Map, or Object\n   */\n  toJSON(_, ctx, Type) {\n    const map = Type ? new Type() : ctx !== null && ctx !== void 0 && ctx.mapAsMap ? new Map() : {};\n    if (ctx !== null && ctx !== void 0 && ctx.onCreate) ctx.onCreate(map);\n    for (const item of this.items) addPairToJSMap(ctx, map, item);\n    return map;\n  }\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n    for (const item of this.items) {\n      if (!isPair(item)) throw new Error(\"Map items must all be pairs; found \".concat(JSON.stringify(item), \" instead\"));\n    }\n    if (!ctx.allNullValues && this.hasAllNullValues(false)) ctx = Object.assign({}, ctx, {\n      allNullValues: true\n    });\n    return stringifyCollection(this, ctx, {\n      blockItemPrefix: '',\n      flowChars: {\n        start: '{',\n        end: '}'\n      },\n      itemIndent: ctx.indent || '',\n      onChompKeep,\n      onComment\n    });\n  }\n}\nexport { YAMLMap, findPair };","map":{"version":3,"names":["stringifyCollection","addPairToJSMap","Collection","isPair","isScalar","MAP","Pair","createPair","isScalarValue","findPair","items","key","k","value","it","undefined","YAMLMap","tagName","constructor","schema","from","obj","ctx","keepUndefined","replacer","map","add","call","Array","isArray","includes","push","Map","Object","keys","sortMapEntries","sort","pair","overwrite","_this$schema","_pair","prev","sortEntries","Error","concat","i","findIndex","item","splice","delete","del","indexOf","length","get","keepScalar","_ref","node","has","set","toJSON","_","Type","mapAsMap","onCreate","toString","onComment","onChompKeep","JSON","stringify","allNullValues","hasAllNullValues","assign","blockItemPrefix","flowChars","start","end","itemIndent","indent"],"sources":["/Users/shoukaiwen/WebstormProjects/alluxio-k8s-operator-ui/node_modules/yaml/browser/dist/nodes/YAMLMap.js"],"sourcesContent":["import { stringifyCollection } from '../stringify/stringifyCollection.js';\nimport { addPairToJSMap } from './addPairToJSMap.js';\nimport { Collection } from './Collection.js';\nimport { isPair, isScalar, MAP } from './identity.js';\nimport { Pair, createPair } from './Pair.js';\nimport { isScalarValue } from './Scalar.js';\n\nfunction findPair(items, key) {\n    const k = isScalar(key) ? key.value : key;\n    for (const it of items) {\n        if (isPair(it)) {\n            if (it.key === key || it.key === k)\n                return it;\n            if (isScalar(it.key) && it.key.value === k)\n                return it;\n        }\n    }\n    return undefined;\n}\nclass YAMLMap extends Collection {\n    static get tagName() {\n        return 'tag:yaml.org,2002:map';\n    }\n    constructor(schema) {\n        super(MAP, schema);\n        this.items = [];\n    }\n    /**\n     * A generic collection parsing method that can be extended\n     * to other node classes that inherit from YAMLMap\n     */\n    static from(schema, obj, ctx) {\n        const { keepUndefined, replacer } = ctx;\n        const map = new this(schema);\n        const add = (key, value) => {\n            if (typeof replacer === 'function')\n                value = replacer.call(obj, key, value);\n            else if (Array.isArray(replacer) && !replacer.includes(key))\n                return;\n            if (value !== undefined || keepUndefined)\n                map.items.push(createPair(key, value, ctx));\n        };\n        if (obj instanceof Map) {\n            for (const [key, value] of obj)\n                add(key, value);\n        }\n        else if (obj && typeof obj === 'object') {\n            for (const key of Object.keys(obj))\n                add(key, obj[key]);\n        }\n        if (typeof schema.sortMapEntries === 'function') {\n            map.items.sort(schema.sortMapEntries);\n        }\n        return map;\n    }\n    /**\n     * Adds a value to the collection.\n     *\n     * @param overwrite - If not set `true`, using a key that is already in the\n     *   collection will throw. Otherwise, overwrites the previous value.\n     */\n    add(pair, overwrite) {\n        let _pair;\n        if (isPair(pair))\n            _pair = pair;\n        else if (!pair || typeof pair !== 'object' || !('key' in pair)) {\n            // In TypeScript, this never happens.\n            _pair = new Pair(pair, pair?.value);\n        }\n        else\n            _pair = new Pair(pair.key, pair.value);\n        const prev = findPair(this.items, _pair.key);\n        const sortEntries = this.schema?.sortMapEntries;\n        if (prev) {\n            if (!overwrite)\n                throw new Error(`Key ${_pair.key} already set`);\n            // For scalars, keep the old node & its comments and anchors\n            if (isScalar(prev.value) && isScalarValue(_pair.value))\n                prev.value.value = _pair.value;\n            else\n                prev.value = _pair.value;\n        }\n        else if (sortEntries) {\n            const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);\n            if (i === -1)\n                this.items.push(_pair);\n            else\n                this.items.splice(i, 0, _pair);\n        }\n        else {\n            this.items.push(_pair);\n        }\n    }\n    delete(key) {\n        const it = findPair(this.items, key);\n        if (!it)\n            return false;\n        const del = this.items.splice(this.items.indexOf(it), 1);\n        return del.length > 0;\n    }\n    get(key, keepScalar) {\n        const it = findPair(this.items, key);\n        const node = it?.value;\n        return (!keepScalar && isScalar(node) ? node.value : node) ?? undefined;\n    }\n    has(key) {\n        return !!findPair(this.items, key);\n    }\n    set(key, value) {\n        this.add(new Pair(key, value), true);\n    }\n    /**\n     * @param ctx - Conversion context, originally set in Document#toJS()\n     * @param {Class} Type - If set, forces the returned collection type\n     * @returns Instance of Type, Map, or Object\n     */\n    toJSON(_, ctx, Type) {\n        const map = Type ? new Type() : ctx?.mapAsMap ? new Map() : {};\n        if (ctx?.onCreate)\n            ctx.onCreate(map);\n        for (const item of this.items)\n            addPairToJSMap(ctx, map, item);\n        return map;\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        for (const item of this.items) {\n            if (!isPair(item))\n                throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);\n        }\n        if (!ctx.allNullValues && this.hasAllNullValues(false))\n            ctx = Object.assign({}, ctx, { allNullValues: true });\n        return stringifyCollection(this, ctx, {\n            blockItemPrefix: '',\n            flowChars: { start: '{', end: '}' },\n            itemIndent: ctx.indent || '',\n            onChompKeep,\n            onComment\n        });\n    }\n}\n\nexport { YAMLMap, findPair };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}