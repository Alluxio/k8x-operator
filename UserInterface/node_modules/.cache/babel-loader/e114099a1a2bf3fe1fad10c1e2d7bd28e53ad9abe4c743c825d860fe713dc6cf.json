{"ast":null,"code":"import { isNode } from '../nodes/identity.js';\nimport { visit } from '../visit.js';\nconst escapeChars = {\n  '!': '%21',\n  ',': '%2C',\n  '[': '%5B',\n  ']': '%5D',\n  '{': '%7B',\n  '}': '%7D'\n};\nconst escapeTagName = tn => tn.replace(/[!,[\\]{}]/g, ch => escapeChars[ch]);\nclass Directives {\n  constructor(yaml, tags) {\n    /**\n     * The directives-end/doc-start marker `---`. If `null`, a marker may still be\n     * included in the document's stringified representation.\n     */\n    this.docStart = null;\n    /** The doc-end marker `...`.  */\n    this.docEnd = false;\n    this.yaml = Object.assign({}, Directives.defaultYaml, yaml);\n    this.tags = Object.assign({}, Directives.defaultTags, tags);\n  }\n  clone() {\n    const copy = new Directives(this.yaml, this.tags);\n    copy.docStart = this.docStart;\n    return copy;\n  }\n  /**\n   * During parsing, get a Directives instance for the current document and\n   * update the stream state according to the current version's spec.\n   */\n  atDocument() {\n    const res = new Directives(this.yaml, this.tags);\n    switch (this.yaml.version) {\n      case '1.1':\n        this.atNextDocument = true;\n        break;\n      case '1.2':\n        this.atNextDocument = false;\n        this.yaml = {\n          explicit: Directives.defaultYaml.explicit,\n          version: '1.2'\n        };\n        this.tags = Object.assign({}, Directives.defaultTags);\n        break;\n    }\n    return res;\n  }\n  /**\n   * @param onError - May be called even if the action was successful\n   * @returns `true` on success\n   */\n  add(line, onError) {\n    if (this.atNextDocument) {\n      this.yaml = {\n        explicit: Directives.defaultYaml.explicit,\n        version: '1.1'\n      };\n      this.tags = Object.assign({}, Directives.defaultTags);\n      this.atNextDocument = false;\n    }\n    const parts = line.trim().split(/[ \\t]+/);\n    const name = parts.shift();\n    switch (name) {\n      case '%TAG':\n        {\n          if (parts.length !== 2) {\n            onError(0, '%TAG directive should contain exactly two parts');\n            if (parts.length < 2) return false;\n          }\n          const [handle, prefix] = parts;\n          this.tags[handle] = prefix;\n          return true;\n        }\n      case '%YAML':\n        {\n          this.yaml.explicit = true;\n          if (parts.length !== 1) {\n            onError(0, '%YAML directive should contain exactly one part');\n            return false;\n          }\n          const [version] = parts;\n          if (version === '1.1' || version === '1.2') {\n            this.yaml.version = version;\n            return true;\n          } else {\n            const isValid = /^\\d+\\.\\d+$/.test(version);\n            onError(6, \"Unsupported YAML version \".concat(version), isValid);\n            return false;\n          }\n        }\n      default:\n        onError(0, \"Unknown directive \".concat(name), true);\n        return false;\n    }\n  }\n  /**\n   * Resolves a tag, matching handles to those defined in %TAG directives.\n   *\n   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a\n   *   `'!local'` tag, or `null` if unresolvable.\n   */\n  tagName(source, onError) {\n    if (source === '!') return '!'; // non-specific tag\n    if (source[0] !== '!') {\n      onError(\"Not a valid tag: \".concat(source));\n      return null;\n    }\n    if (source[1] === '<') {\n      const verbatim = source.slice(2, -1);\n      if (verbatim === '!' || verbatim === '!!') {\n        onError(\"Verbatim tags aren't resolved, so \".concat(source, \" is invalid.\"));\n        return null;\n      }\n      if (source[source.length - 1] !== '>') onError('Verbatim tags must end with a >');\n      return verbatim;\n    }\n    const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);\n    if (!suffix) onError(\"The \".concat(source, \" tag has no suffix\"));\n    const prefix = this.tags[handle];\n    if (prefix) {\n      try {\n        return prefix + decodeURIComponent(suffix);\n      } catch (error) {\n        onError(String(error));\n        return null;\n      }\n    }\n    if (handle === '!') return source; // local tag\n    onError(\"Could not resolve tag: \".concat(source));\n    return null;\n  }\n  /**\n   * Given a fully resolved tag, returns its printable string form,\n   * taking into account current tag prefixes and defaults.\n   */\n  tagString(tag) {\n    for (const [handle, prefix] of Object.entries(this.tags)) {\n      if (tag.startsWith(prefix)) return handle + escapeTagName(tag.substring(prefix.length));\n    }\n    return tag[0] === '!' ? tag : \"!<\".concat(tag, \">\");\n  }\n  toString(doc) {\n    const lines = this.yaml.explicit ? [\"%YAML \".concat(this.yaml.version || '1.2')] : [];\n    const tagEntries = Object.entries(this.tags);\n    let tagNames;\n    if (doc && tagEntries.length > 0 && isNode(doc.contents)) {\n      const tags = {};\n      visit(doc.contents, (_key, node) => {\n        if (isNode(node) && node.tag) tags[node.tag] = true;\n      });\n      tagNames = Object.keys(tags);\n    } else tagNames = [];\n    for (const [handle, prefix] of tagEntries) {\n      if (handle === '!!' && prefix === 'tag:yaml.org,2002:') continue;\n      if (!doc || tagNames.some(tn => tn.startsWith(prefix))) lines.push(\"%TAG \".concat(handle, \" \").concat(prefix));\n    }\n    return lines.join('\\n');\n  }\n}\nDirectives.defaultYaml = {\n  explicit: false,\n  version: '1.2'\n};\nDirectives.defaultTags = {\n  '!!': 'tag:yaml.org,2002:'\n};\nexport { Directives };","map":{"version":3,"names":["isNode","visit","escapeChars","escapeTagName","tn","replace","ch","Directives","constructor","yaml","tags","docStart","docEnd","Object","assign","defaultYaml","defaultTags","clone","copy","atDocument","res","version","atNextDocument","explicit","add","line","onError","parts","trim","split","name","shift","length","handle","prefix","isValid","test","concat","tagName","source","verbatim","slice","suffix","match","decodeURIComponent","error","String","tagString","tag","entries","startsWith","substring","toString","doc","lines","tagEntries","tagNames","contents","_key","node","keys","some","push","join"],"sources":["/Users/shoukaiwen/WebstormProjects/alluxio-k8s-operator-ui/node_modules/yaml/browser/dist/doc/directives.js"],"sourcesContent":["import { isNode } from '../nodes/identity.js';\nimport { visit } from '../visit.js';\n\nconst escapeChars = {\n    '!': '%21',\n    ',': '%2C',\n    '[': '%5B',\n    ']': '%5D',\n    '{': '%7B',\n    '}': '%7D'\n};\nconst escapeTagName = (tn) => tn.replace(/[!,[\\]{}]/g, ch => escapeChars[ch]);\nclass Directives {\n    constructor(yaml, tags) {\n        /**\n         * The directives-end/doc-start marker `---`. If `null`, a marker may still be\n         * included in the document's stringified representation.\n         */\n        this.docStart = null;\n        /** The doc-end marker `...`.  */\n        this.docEnd = false;\n        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);\n        this.tags = Object.assign({}, Directives.defaultTags, tags);\n    }\n    clone() {\n        const copy = new Directives(this.yaml, this.tags);\n        copy.docStart = this.docStart;\n        return copy;\n    }\n    /**\n     * During parsing, get a Directives instance for the current document and\n     * update the stream state according to the current version's spec.\n     */\n    atDocument() {\n        const res = new Directives(this.yaml, this.tags);\n        switch (this.yaml.version) {\n            case '1.1':\n                this.atNextDocument = true;\n                break;\n            case '1.2':\n                this.atNextDocument = false;\n                this.yaml = {\n                    explicit: Directives.defaultYaml.explicit,\n                    version: '1.2'\n                };\n                this.tags = Object.assign({}, Directives.defaultTags);\n                break;\n        }\n        return res;\n    }\n    /**\n     * @param onError - May be called even if the action was successful\n     * @returns `true` on success\n     */\n    add(line, onError) {\n        if (this.atNextDocument) {\n            this.yaml = { explicit: Directives.defaultYaml.explicit, version: '1.1' };\n            this.tags = Object.assign({}, Directives.defaultTags);\n            this.atNextDocument = false;\n        }\n        const parts = line.trim().split(/[ \\t]+/);\n        const name = parts.shift();\n        switch (name) {\n            case '%TAG': {\n                if (parts.length !== 2) {\n                    onError(0, '%TAG directive should contain exactly two parts');\n                    if (parts.length < 2)\n                        return false;\n                }\n                const [handle, prefix] = parts;\n                this.tags[handle] = prefix;\n                return true;\n            }\n            case '%YAML': {\n                this.yaml.explicit = true;\n                if (parts.length !== 1) {\n                    onError(0, '%YAML directive should contain exactly one part');\n                    return false;\n                }\n                const [version] = parts;\n                if (version === '1.1' || version === '1.2') {\n                    this.yaml.version = version;\n                    return true;\n                }\n                else {\n                    const isValid = /^\\d+\\.\\d+$/.test(version);\n                    onError(6, `Unsupported YAML version ${version}`, isValid);\n                    return false;\n                }\n            }\n            default:\n                onError(0, `Unknown directive ${name}`, true);\n                return false;\n        }\n    }\n    /**\n     * Resolves a tag, matching handles to those defined in %TAG directives.\n     *\n     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a\n     *   `'!local'` tag, or `null` if unresolvable.\n     */\n    tagName(source, onError) {\n        if (source === '!')\n            return '!'; // non-specific tag\n        if (source[0] !== '!') {\n            onError(`Not a valid tag: ${source}`);\n            return null;\n        }\n        if (source[1] === '<') {\n            const verbatim = source.slice(2, -1);\n            if (verbatim === '!' || verbatim === '!!') {\n                onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);\n                return null;\n            }\n            if (source[source.length - 1] !== '>')\n                onError('Verbatim tags must end with a >');\n            return verbatim;\n        }\n        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);\n        if (!suffix)\n            onError(`The ${source} tag has no suffix`);\n        const prefix = this.tags[handle];\n        if (prefix) {\n            try {\n                return prefix + decodeURIComponent(suffix);\n            }\n            catch (error) {\n                onError(String(error));\n                return null;\n            }\n        }\n        if (handle === '!')\n            return source; // local tag\n        onError(`Could not resolve tag: ${source}`);\n        return null;\n    }\n    /**\n     * Given a fully resolved tag, returns its printable string form,\n     * taking into account current tag prefixes and defaults.\n     */\n    tagString(tag) {\n        for (const [handle, prefix] of Object.entries(this.tags)) {\n            if (tag.startsWith(prefix))\n                return handle + escapeTagName(tag.substring(prefix.length));\n        }\n        return tag[0] === '!' ? tag : `!<${tag}>`;\n    }\n    toString(doc) {\n        const lines = this.yaml.explicit\n            ? [`%YAML ${this.yaml.version || '1.2'}`]\n            : [];\n        const tagEntries = Object.entries(this.tags);\n        let tagNames;\n        if (doc && tagEntries.length > 0 && isNode(doc.contents)) {\n            const tags = {};\n            visit(doc.contents, (_key, node) => {\n                if (isNode(node) && node.tag)\n                    tags[node.tag] = true;\n            });\n            tagNames = Object.keys(tags);\n        }\n        else\n            tagNames = [];\n        for (const [handle, prefix] of tagEntries) {\n            if (handle === '!!' && prefix === 'tag:yaml.org,2002:')\n                continue;\n            if (!doc || tagNames.some(tn => tn.startsWith(prefix)))\n                lines.push(`%TAG ${handle} ${prefix}`);\n        }\n        return lines.join('\\n');\n    }\n}\nDirectives.defaultYaml = { explicit: false, version: '1.2' };\nDirectives.defaultTags = { '!!': 'tag:yaml.org,2002:' };\n\nexport { Directives };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}